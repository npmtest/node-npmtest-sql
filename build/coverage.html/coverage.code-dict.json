{"/home/travis/build/npmtest/node-npmtest-sql/test.js":"/* istanbul instrument in package npmtest_sql */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sql/lib.npmtest_sql.js":"/* istanbul instrument in package npmtest_sql */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sql = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sql = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sql/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sql && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sql */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sql\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sql.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_sql.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sql.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_sql.__dirname + '/lib.npmtest_sql.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/index.js":"'use strict';\r\n\r\nvar _            = require('lodash');\r\nvar Column \t\t = require(\"./column\");\r\nvar FunctionCall = require('./node/functionCall');\r\nvar ArrayCall    = require('./node/arrayCall');\r\nvar functions    = require('./functions');\r\nvar getDialect   = require('./dialect');\r\nvar Query        = require('./node/query');\r\nvar sliced       = require('sliced');\r\nvar Table        = require('./table');\r\nvar Interval     = require('./node/interval');\r\n\r\n// default dialect is postgres\r\nvar DEFAULT_DIALECT = 'postgres';\r\n\r\nvar Sql = function(dialect, config) {\r\n  this.setDialect(dialect || DEFAULT_DIALECT, config);\r\n\r\n  // attach the standard SQL functions to this instance\r\n  this.functions = functions.getStandardFunctions();\r\n};\r\n\r\n// Define a table\r\nSql.prototype.define = function(def) {\r\n  def = _.defaults(def || {}, {\r\n    sql: this\r\n  });\r\n\r\n  return Table.define(def);\r\n};\r\n\r\n// Returns a function call creator\r\nSql.prototype.functionCallCreator = function(name) {\r\n  return function() {\r\n    return new FunctionCall(name, sliced(arguments));\r\n  };\r\n};\r\n\r\n// Returns a bracketed call creator literal\r\nSql.prototype.array = function() {\r\n  var arrayCall = new ArrayCall(sliced(arguments));\r\n  arrayCall.sql = this;\r\n  return arrayCall;\r\n};\r\n\r\n// Returns a select statement\r\nSql.prototype.select = function() {\r\n  var query = new Query({sql: this});\r\n  query.select.apply(query, arguments);\r\n  return query;\r\n};\r\n\r\n// Returns an interval clause\r\nSql.prototype.interval = function() {\r\n  var interval = new Interval(sliced(arguments));\r\n  return interval;\r\n};\r\n\r\n// Set the dialect\r\nSql.prototype.setDialect = function(dialect, config) {\r\n  this.dialect     = getDialect(dialect);\r\n  this.dialectName = dialect;\r\n  this.config      = config;\r\n\r\n  return this;\r\n};\r\n\r\n// Create a constant Column (for use in SELECT)\r\nSql.prototype.constant = function(value) {\r\n  var config={\r\n    name:\"constant\",\r\n    property:\"constant\",\r\n    isConstant:true,\r\n    constantValue:value,\r\n  };\r\n  var cn = new Column(config);\r\n  return cn;\r\n};\r\n\r\n\r\n// back compat shim for the Sql class constructor\r\nvar create = function(dialect, config) {\r\n  return new Sql(dialect, {});\r\n};\r\n\r\nmodule.exports = new Sql(DEFAULT_DIALECT, {});\r\nmodule.exports.create = create;\r\nmodule.exports.Sql = Sql;\r\nmodule.exports.Table = Table;\r\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/column.js":"'use strict';\n\nvar _                    = require('lodash');\nvar ColumnNode           = require('./node/column');\nvar OrderByValueNode     = require('./node/orderByValue');\nvar TextNode             = require('./node/text');\nvar valueExpressionMixin = require('./node/valueExpression');\n\nvar Column = function(config) {\n  this.table = config.table;\n  for (var name in config) {\n    if (config.hasOwnProperty(name)) {\n      this[name] = config[name];\n    }\n  }\n  this.asc = this.ascending = this;\n  this.alias = null;\n  this.desc = this.descending = new OrderByValueNode({\n    value     : this.toNode(),\n    direction : new TextNode('DESC')\n  });\n  this.dataType = config.dataType;\n  this.defaultValue = config.defaultValue;\n};\n\n// mix in value expression\n_.extend(Column.prototype, valueExpressionMixin());\n\nvar contextify = function(base) {\n  var context = Object.create(Column.prototype);\n  Object.keys(base).forEach(function (key) {\n    context[key] = base[key];\n  });\n  return context;\n};\n\nColumn.prototype.value = function(value) {\n  var context = contextify(this);\n  context._value = value;\n  return context;\n};\n\nColumn.prototype.getValue = function() {\n  return this._value;\n};\n\nColumn.prototype.toNode = function() {\n  // creates a query node from this column\n  return new ColumnNode(contextify(this));\n};\n\nColumn.prototype.as = function(alias) {\n  var context = contextify(this);\n  context.alias = alias;\n  return new ColumnNode(context);\n};\n\nColumn.prototype.arrayAgg = function(alias) {\n  var context = contextify(this);\n  context.asArray = true;\n  context.alias = alias || context.name + 's';\n  return new ColumnNode(context);\n};\n\nColumn.prototype.aggregate = function(alias, aggregator) {\n  var context = contextify(this);\n  context.aggregator = aggregator.toUpperCase();\n  context.alias = alias || context.name + '_' + context.aggregator.toLowerCase();\n  return new ColumnNode(context);\n};\n\nColumn.prototype.count = function(alias) {\n  return this.aggregate(alias, 'count');\n};\n\nColumn.prototype.min = function(alias) {\n  return this.aggregate(alias, 'min');\n};\n\nColumn.prototype.max = function(alias) {\n  return this.aggregate(alias, 'max');\n};\n\nColumn.prototype.sum = function(alias) {\n  return this.aggregate(alias, 'sum');\n};\n\nColumn.prototype.avg = function(alias) {\n  return this.aggregate(alias, 'avg');\n};\n\nColumn.prototype.distinct = function() {\n  var context = contextify(this);\n  context.distinct = true;\n  return new ColumnNode(context);\n};\n\nColumn.prototype.toQuery = function() {\n  return this.toNode().toQuery();\n};\n\nmodule.exports = Column;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/column.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'COLUMN',\n  constructor: function(config) {\n    Node.call(this);\n    this.name = config.name;\n    this.property = config.property || config.name;\n    this.alias = config.alias;\n    this.star = config.star;\n    this.isConstant = config.isConstant;\n    this.constantValue = config.constantValue;\n    this.asArray = config.asArray;\n    this.aggregator = config.aggregator;\n    this.table = config.table;\n    this.value = config.getValue();\n    this.dataType = config.dataType;\n    this.distinct = config.distinct;\n    this.primaryKey = config.primaryKey;\n    this.notNull = config.notNull;\n    this.defaultValue = config.defaultValue;\n    this.references = config.references;\n    // If subfieldContainer is present, this is a subfield and subfieldContainer\n    // is the parent Column\n    this.subfieldContainer = config.subfieldContainer;\n    this.subfields = config.subfields;\n    this.autoGenerated = !!config.autoGenerated;\n    this.unique = !!config.unique;\n  },\n  as: function(alias) {\n    this.alias = alias;\n    return this;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/index.js":"'use strict';\n\nvar assert     = require('assert');\nvar getDialect = require('../dialect');\nvar util       = require('util');\n\nvar Node = function(type) {\n  /* jshint unused: false */\n  this.nodes = [];\n};\n\nNode.prototype.toNode = function() {\n  return this;\n};\n\nNode.prototype.add = function(node) {\n  assert(node, 'Error while trying to add a non-existant node to a query');\n\tvar newNode;\n  if (typeof node === 'string') newNode = new TextNode(node);\n  else if (node.toNode) newNode = node.toNode();\n  else newNode = node;\n  this.nodes.push(newNode);\n  return this;\n};\n\nNode.prototype.unshift = function(node) {\n  assert(node, 'Error while trying to add a non-existant node to a query');\n  this.nodes.unshift(typeof node === 'string' ? new TextNode(node) : node.toNode());\n  return this;\n};\n\n// Before the change that introduced parallel dialects, every node could be turned\n// into a query. The parallel dialects change made it impossible to change some nodes\n// into a query because not all nodes are constructed with the sql instance.\nvar determineDialect = function(query, dialect) {\n  var sql = query.sql || (query.table && query.table.sql);\n  var Dialect;\n\n  if (dialect) {\n    // dialect is specified\n    Dialect = getDialect(dialect);\n  } else if (sql && sql.dialect) {\n    // dialect is not specified, use the dialect from the sql instance\n    Dialect = sql.dialect;\n  } else {\n    // dialect is not specified, use the default dialect\n    Dialect = require('../').dialect;\n  }\n  return Dialect;\n};\n\nvar initializeDialect = function(Dialect, query) {\n    var config = query.sql ? query.sql.config : {};\n    return new Dialect(config);\n};\n\nNode.prototype.toQuery = function(dialect) {\n  var Dialect = determineDialect(this, dialect);\n  return initializeDialect(Dialect, this).getQuery(this);\n};\n\nNode.prototype.toNamedQuery = function(name, dialect) {\n  if (!name || typeof name !== 'string' ||  name === '') {\n    throw new Error('A query name has to be a non-empty String.');\n  }\n  var query = this.toQuery(dialect);\n  query.name = name;\n  return query;\n};\n\nNode.prototype.toString = function(dialect) {\n  var Dialect = determineDialect(this, dialect);\n  return initializeDialect(Dialect, this).getString(this);\n};\n\nNode.prototype.addAll = function(nodes) {\n  for(var i = 0, len = nodes.length; i < len; i++) {\n    this.add(nodes[i]);\n  }\n  return this;\n};\n\nNode.define = function(def) {\n  var c = function() {\n    Node.call(this);\n  };\n  // allow custom sub-class constructor\n  if(def.constructor && def.constructor !== {}.constructor) {\n    c = def.constructor;\n  }\n  util.inherits(c, Node);\n  for (var key in def) {\n    if (def.hasOwnProperty(key)) {\n      c.prototype[key] = def[key];\n    }\n  }\n  return c;\n};\n\nmodule.exports = Node;\nvar TextNode = require('./text');\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/dialect/index.js":"'use strict';\n\n// given a dialect name, return the class\nvar getDialect = function(dialect) {\n  switch (dialect.toLowerCase()) {\n    case 'postgres':\n      return require('./postgres');\n    case 'mysql':\n      return require('./mysql');\n    case 'sqlite':\n      return require('./sqlite');\n    case 'mssql':\n      return require('./mssql');\n    case 'oracle':\n      return require('./oracle');\n    default:\n      throw new Error(dialect + ' is unsupported');\n  }\n};\n\nmodule.exports = getDialect;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/text.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'TEXT',\n  constructor: function(text) {\n    Node.call(this);\n    this.text = text;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/orderByValue.js":"'use strict';\n\nvar Node = require('./index');\n\nvar OrderByColumn = Node.define({\n  type: 'ORDER BY VALUE',\n  constructor: function(config) {\n    Node.call(this);\n    this.value = config.value;\n    this.direction = config.direction;\n    // used when processing OFFSET and LIMIT clauses in MSSQL\n    this.msSQLOffsetNode=undefined;\n    this.msSQLLimitNode=undefined;\n  }\n});\n\n module.exports = OrderByColumn;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/valueExpression.js":"'use strict';\n\nvar OrderByValueNode = require('./orderByValue');\nvar ParameterNode    = require('./parameter');\nvar TextNode         = require('./text');\n\n// Process values, wrapping them in ParameterNode if necessary.\nvar processParams = function(val) {\n  return Array.isArray(val) ? val.map(ParameterNode.getNodeOrParameterNode) : ParameterNode.getNodeOrParameterNode(val);\n};\n\n// Value expressions can be composed to form new value expressions.\n// ValueExpressionMixin is evaluated at runtime, hence the\n// \"thunk\" around it.\nvar ValueExpressionMixin = function() {\n  var BinaryNode       = require('./binary');\n  var InNode           = require('./in');\n  var NotInNode        = require('./notIn');\n  var CastNode         = require('./cast');\n  var PostfixUnaryNode = require('./postfixUnary');\n  var TernaryNode      = require('./ternary');\n  var CaseNode         = require('./case');\n  var AtNode           = require('./at');\n  var SliceNode        = require('./slice');\n\n  var postfixUnaryMethod = function(operator) {\n    /*jshint unused: false */\n    return function(val) {\n      return new PostfixUnaryNode({\n        left     : this.toNode(),\n        operator : operator\n      });\n    };\n  };\n\n  var binaryMethod = function(operator) {\n    return function(val) {\n      return new BinaryNode({\n        left     : this.toNode(),\n        operator : operator,\n        right    : processParams(val)\n      });\n    };\n  };\n\n  var inMethod = function(val) {\n    return new InNode({\n      left  : this.toNode(),\n      right : processParams(val)\n    });\n  };\n\n  var notInMethod = function(val) {\n    return new NotInNode({\n      left  : this.toNode(),\n      right : processParams(val)\n    });\n  };\n\n  var ternaryMethod = function(operator, separator) {\n    return function(middle, right) {\n      return new TernaryNode({\n        left      : this.toNode(),\n        operator  : operator,\n        middle    : processParams(middle),\n        separator : separator,\n        right     : processParams(right)\n      });\n    };\n  };\n\n  var atMethod = function(index) {\n    return new AtNode(this.toNode(), processParams(index));\n  };\n\n  var sliceMethod = function(start, end) {\n    return new SliceNode(this.toNode(), processParams(start), processParams(end));\n  };\n\n  var castMethod = function(dataType) {\n    return new CastNode(this.toNode(), dataType);\n  };\n\n  var orderMethod = function(direction) {\n    return function() {\n      return new OrderByValueNode({\n        value     : this.toNode(),\n        direction : direction ? new TextNode(direction) : undefined\n      });\n    };\n  };\n\n  var caseMethod = function(whenList, thenList, elseBranch) {\n    if (undefined !== elseBranch) {\n      elseBranch = processParams(elseBranch);\n    }\n    return new CaseNode({\n      whenList : processParams(whenList),\n      thenList : processParams(thenList),\n      else     : elseBranch\n    });\n  };\n\n  return {\n    isNull     : postfixUnaryMethod('IS NULL'),\n    isNotNull  : postfixUnaryMethod('IS NOT NULL'),\n    or         : binaryMethod('OR'),\n    and        : binaryMethod('AND'),\n    equals     : binaryMethod('='),\n    equal      : binaryMethod('='),\n    notEquals  : binaryMethod('<>'),\n    notEqual   : binaryMethod('<>'),\n    gt         : binaryMethod('>'),\n    gte        : binaryMethod('>='),\n    lt         : binaryMethod('<'),\n    lte        : binaryMethod('<='),\n    plus       : binaryMethod('+'),\n    minus      : binaryMethod('-'),\n    multiply   : binaryMethod('*'),\n    divide     : binaryMethod('/'),\n    modulo     : binaryMethod('%'),\n    leftShift  : binaryMethod('<<'),\n    rightShift : binaryMethod('>>'),\n    bitwiseAnd : binaryMethod('&'),\n    bitwiseNot : binaryMethod('~'),\n    bitwiseOr  : binaryMethod('|'),\n    bitwiseXor : binaryMethod('#'),\n    regex      : binaryMethod('~'),\n    iregex     : binaryMethod('~*'),\n    regexp     : binaryMethod('REGEXP'),\n    notRegex   : binaryMethod('!~'),\n    notIregex   : binaryMethod('!~*'),\n    concat     : binaryMethod('||'),\n    key        : binaryMethod('->'),\n    keyText    : binaryMethod('->>'),\n    path       : binaryMethod('#>'),\n    pathText   : binaryMethod('#>>'),\n    like       : binaryMethod('LIKE'),\n    rlike      : binaryMethod('RLIKE'),\n    notLike    : binaryMethod('NOT LIKE'),\n    ilike       : binaryMethod('ILIKE'),\n    notIlike    : binaryMethod('NOT ILIKE'),\n    match      : binaryMethod('@@'),\n    in         : inMethod,\n    notIn      : notInMethod,\n    between    : ternaryMethod('BETWEEN', 'AND'),\n    notBetween : ternaryMethod('NOT BETWEEN', 'AND'),\n    at         : atMethod,\n    contains   : binaryMethod('@>'),\n    containedBy : binaryMethod('<@'),\n    containsKey : binaryMethod('?'),\n    overlap    : binaryMethod('&&'),\n    slice      : sliceMethod,\n    cast       : castMethod,\n    descending : orderMethod('DESC'),\n    case       : caseMethod\n  };\n};\n\nmodule.exports = ValueExpressionMixin;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/parameter.js":"'use strict';\n\nvar Node = require('./index');\n\nvar ParameterNode = module.exports = Node.define({\n  type: 'PARAMETER',\n  constructor: function(val) {\n    Node.call(this);\n    this._val = val;\n    this.isExplicit = false;\n  },\n  value: function() {\n    return this._val;\n  }\n});\n\n// wrap a value as a parameter node if value is not already a node\nmodule.exports.getNodeOrParameterNode = function(value) {\n  if (value && value.toNode) {\n    // use toNode\n    return value.toNode();\n  } else {\n    // wrap as parameter node\n    return new ParameterNode(value);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/binary.js":"'use strict';\n\nvar _                    = require('lodash');\nvar Node                 = require('./index');\nvar valueExpressionMixin = require('./valueExpression');\n\nvar valueExpressionMixed = false;\nvar BinaryNode = Node.define(_.extend({\n  type: 'BINARY',\n  constructor: function(config) {\n    Node.call(this);\n    this.left = config.left;\n    this.operator = config.operator;\n    this.right = config.right;\n\n    // Delay mixin to runtime, when all nodes have been defined, and\n    // mixin only once. ValueExpressionMixin has circular dependencies.\n    if (!valueExpressionMixed) {\n      valueExpressionMixed = true;\n      _.extend(BinaryNode.prototype, valueExpressionMixin());\n    }\n  },\n}));\n\n// allow aliasing\nvar AliasNode = require('./alias');\n_.extend(BinaryNode.prototype, AliasNode.AliasMixin);\n\nmodule.exports = BinaryNode;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/alias.js":"'use strict';\n\nvar _ = require('lodash');\nvar Node = require('./index');\n\nvar AliasNode = Node.define({\n  type: 'ALIAS',\n  constructor: function(value, alias) {\n    Node.call(this);\n\n    this.value = value;\n    this.alias = alias;\n  }\n});\n\nvar AliasMixin = {\n  as: function(alias) {\n    // create an alias node\n    var aliasNode = new AliasNode(this, alias);\n\n    // defaults the properties of the aliased node\n    _.defaults(aliasNode, this);\n\n    return aliasNode;\n  }\n};\n\nmodule.exports = AliasNode;\nmodule.exports.AliasMixin = AliasMixin;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/in.js":"'use strict';\n\nvar _                    = require('lodash');\nvar Node                 = require('./index');\nvar valueExpressionMixin = require('./valueExpression');\n\nvar valueExpressionMixed = false;\nvar InNode = Node.define(_.extend({\n  type: 'IN',\n  constructor: function(config) {\n    Node.call(this);\n    this.left = config.left;\n    this.right = config.right;\n\n    // Delay mixin to runtime, when all nodes have been defined, and\n    // mixin only once. ValueExpressionMixin has circular dependencies.\n    if (!valueExpressionMixed) {\n      valueExpressionMixed = true;\n      _.extend(InNode.prototype, valueExpressionMixin());\n    }\n  },\n}));\n\n// allow aliasing\nvar AliasNode = require('./alias');\n_.extend(InNode.prototype, AliasNode.AliasMixin);\n\nmodule.exports = InNode;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/notIn.js":"'use strict';\n\nvar _                    = require('lodash');\nvar Node                 = require('./index');\nvar valueExpressionMixin = require('./valueExpression');\n\nvar valueExpressionMixed = false;\nvar NotInNode = Node.define(_.extend({\n  type: 'NOT IN',\n  constructor: function(config) {\n    Node.call(this);\n    this.left = config.left;\n    this.right = config.right;\n\n    // Delay mixin to runtime, when all nodes have been defined, and\n    // mixin only once. ValueExpressionMixin has circular dependencies.\n    if (!valueExpressionMixed) {\n      valueExpressionMixed = true;\n      _.extend(NotInNode.prototype, valueExpressionMixin());\n    }\n  },\n}));\n\n// allow aliasing\nvar AliasNode = require('./alias');\n_.extend(NotInNode.prototype, AliasNode.AliasMixin);\n\nmodule.exports = NotInNode;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/cast.js":"'use strict';\n\nvar _                    = require('lodash');\nvar Node                 = require('./index');\nvar valueExpressionMixin = require('./valueExpression');\n\nvar valueExpressionMixed = false;\nvar CastNode = Node.define({\n  type: 'CAST',\n  constructor: function(value, dataType) {\n    Node.call(this);\n    this.value = value;\n    this.dataType = dataType;\n    // Delay mixin to runtime, when all nodes have been defined, and\n    // mixin only once. ValueExpressionMixin has circular dependencies.\n    if (!valueExpressionMixed) {\n      valueExpressionMixed = true;\n      _.extend(CastNode.prototype, valueExpressionMixin());\n    }\n  }\n});\n\n// allow aliasing\nvar AliasNode = require('./alias');\n_.extend(CastNode.prototype, AliasNode.AliasMixin);\n\nmodule.exports = CastNode;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/postfixUnary.js":"'use strict';\n\nvar _                    = require('lodash');\nvar Node                 = require('./index');\nvar valueExpressionMixin = require('./valueExpression');\n\nvar valueExpressionMixed = false;\nvar PostfixUnaryNode = Node.define({\n  type: 'POSTFIX UNARY',\n  constructor: function(config) {\n    Node.call(this);\n    this.left = config.left;\n    this.operator = config.operator;\n\n    // Delay mixin to runtime, when all nodes have been defined, and\n    // mixin only once. ValueExpressionMixin has circular dependencies.\n    if (!valueExpressionMixed) {\n      valueExpressionMixed = true;\n      _.extend(PostfixUnaryNode.prototype, valueExpressionMixin());\n    }\n  }\n});\n\n// allow aliasing\nvar AliasNode = require('./alias');\n_.extend(PostfixUnaryNode.prototype, AliasNode.AliasMixin);\n\nmodule.exports = PostfixUnaryNode;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/ternary.js":"'use strict';\n\nvar _                    = require('lodash');\nvar Node                 = require('./index');\nvar valueExpressionMixin = require('./valueExpression');\n\nvar valueExpressionMixed = false;\nvar TernaryNode = Node.define(_.extend({\n  type: 'TERNARY',\n  constructor: function(config) {\n    Node.call(this);\n    this.left = config.left;\n    this.middle = config.middle;\n    this.operator = config.operator;\n    this.right = config.right;\n    this.separator = config.separator;\n\n    // Delay mixin to runtime, when all nodes have been defined, and\n    // mixin only once. ValueExpressionMixin has circular dependencies.\n    if (!valueExpressionMixed) {\n      valueExpressionMixed = true;\n      _.extend(TernaryNode.prototype, valueExpressionMixin());\n    }\n  },\n}));\n\n// allow aliasing\nvar AliasNode = require('./alias');\n_.extend(TernaryNode.prototype, AliasNode.AliasMixin);\n\nmodule.exports = TernaryNode;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/case.js":"'use strict';\n\nvar _                    = require('lodash');\nvar Node                 = require('./index');\nvar valueExpressionMixin = require('./valueExpression');\n\nvar valueExpressionMixed = false;\nvar CaseNode = Node.define(_.extend({\n  type: 'CASE',\n  constructor: function(config) {\n    Node.call(this);\n    this.whenList = config.whenList;\n    this.thenList = config.thenList;\n    this.else     = config.else;\n\n    // Delay mixin to runtime, when all nodes have been defined, and\n    // mixin only once. ValueExpressionMixin has circular dependencies.\n    if (!valueExpressionMixed) {\n      valueExpressionMixed = true;\n      _.extend(CaseNode.prototype, valueExpressionMixin());\n    }\n  },\n}));\n\n// allow aliasing\nvar AliasNode = require('./alias');\n_.extend(CaseNode.prototype, AliasNode.AliasMixin);\n\nmodule.exports = CaseNode;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/at.js":"'use strict';\n\nvar _                    = require('lodash');\nvar Node                 = require('./index');\nvar valueExpressionMixin = require('./valueExpression');\n\nvar valueExpressionMixed = false;\nvar AtNode = Node.define({\n  type: 'AT',\n  constructor: function(value, index) {\n    Node.call(this);\n    this.value = value;\n    this.index = index;\n    // Delay mixin to runtime, when all nodes have been defined, and\n    // mixin only once. ValueExpressionMixin has circular dependencies.\n    if (!valueExpressionMixed) {\n      valueExpressionMixed = true;\n      _.extend(AtNode.prototype, valueExpressionMixin());\n    }\n  }\n});\n\n// allow aliasing\nvar AliasNode = require('./alias');\n_.extend(AtNode.prototype, AliasNode.AliasMixin);\n\nmodule.exports = AtNode;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/slice.js":"'use strict';\n\nvar _                    = require('lodash');\nvar Node                 = require('./index');\nvar valueExpressionMixin = require('./valueExpression');\n\nvar valueExpressionMixed = false;\nvar SliceNode = Node.define({\n  type: 'SLICE',\n  constructor: function(value, start, end) {\n    Node.call(this);\n    this.value = value;\n    this.start = start;\n    this.end = end;\n    // Delay mixin to runtime, when all nodes have been defined, and\n    // mixin only once. ValueExpressionMixin has circular dependencies.\n    if (!valueExpressionMixed) {\n      valueExpressionMixed = true;\n      _.extend(SliceNode.prototype, valueExpressionMixin());\n    }\n  }\n});\n\n// allow aliasing\nvar AliasNode = require('./alias');\n_.extend(SliceNode.prototype, AliasNode.AliasMixin);\n\nmodule.exports = SliceNode;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/functionCall.js":"'use strict';\n\nvar _                    = require('lodash');\nvar Node                 = require('./index');\nvar ParameterNode        = require('./parameter');\nvar valueExpressionMixin = require('./valueExpression');\n\nvar FunctionCallNode = Node.define({\n  type: 'FUNCTION CALL',\n  constructor: function(name, args) {\n    Node.call(this);\n    this.name = name;\n    this.addAll(args.map(ParameterNode.getNodeOrParameterNode));\n  }\n});\n\n// mix in value expression\n_.extend(FunctionCallNode.prototype, valueExpressionMixin());\n\n// allow aliasing\nvar AliasNode = require('./alias');\n_.extend(FunctionCallNode.prototype, AliasNode.AliasMixin);\n\nmodule.exports = FunctionCallNode;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/arrayCall.js":"'use strict';\n\nvar _                    = require('lodash');\nvar Node                 = require('./index');\nvar ParameterNode        = require('./parameter');\nvar valueExpressionMixin = require('./valueExpression');\n\nvar ArrayCallNode = Node.define({\n  type: 'ARRAY CALL',\n  constructor: function(args) {\n    Node.call(this);\n    args = _.flatten(args);\n    this.addAll(args.map(ParameterNode.getNodeOrParameterNode));\n  }\n});\n\n// mix in value expression\n_.extend(ArrayCallNode.prototype, valueExpressionMixin());\n\n// allow aliasing\nvar AliasNode = require('./alias');\n_.extend(ArrayCallNode.prototype, AliasNode.AliasMixin);\n\nmodule.exports = ArrayCallNode;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/functions.js":"'use strict';\nvar _ = require('lodash');\nvar sliced = require('sliced');\nvar FunctionCall = require('./node/functionCall');\n\n// create a function that creates a function call of the specific name, using the specified sql instance\nvar getFunctionCallCreator = function(name) {\n  return function() {\n    // turn array-like arguments object into a true array\n    return new FunctionCall(name, sliced(arguments));\n  };\n};\n\n// creates a hash of functions for a sql instance\nvar getFunctions = function(functionNames) {\n  var functions = _.reduce(functionNames, function(reducer, name) {\n    reducer[name] = getFunctionCallCreator(name);\n    return reducer;\n  }, {});\n  return functions;\n};\n\n// aggregate functions available to all databases\nvar aggregateFunctions = [\n  'AVG',\n  'COUNT',\n  'DISTINCT',\n  'MAX',\n  'MIN',\n  'SUM'\n];\n\n// common scalar functions available to most databases\nvar scalarFunctions = [\n  'ABS',\n  'COALESCE',\n  'LEFT',\n  'LENGTH',\n  'LOWER',\n  'LTRIM',\n  'RANDOM',\n  'RIGHT',\n  'ROUND',\n  'RTRIM',\n  'SUBSTR',\n  'TRIM',\n  'UPPER'\n];\n\nvar dateFunctions = [\n  'YEAR',\n  'MONTH',\n  'DAY',\n  'HOUR',\n  'CURRENT_TIMESTAMP'\n];\n\n// hstore function available to Postgres\nvar hstoreFunction = 'HSTORE';\n\n//text search functions available to Postgres\nvar textsearchFunctions = ['TS_RANK','TS_RANK_CD', 'PLAINTO_TSQUERY', 'TO_TSQUERY', 'TO_TSVECTOR', 'SETWEIGHT'];\n\nvar standardFunctionNames = aggregateFunctions.concat(scalarFunctions).concat(hstoreFunction).concat(textsearchFunctions).concat(dateFunctions);\n\n// creates a hash of standard functions for a sql instance\nvar getStandardFunctions = function() {\n  return getFunctions(standardFunctionNames);\n};\n\nmodule.exports.getStandardFunctions = getStandardFunctions;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/query.js":"'use strict';\n\nvar _ = require('lodash');\nvar alias = require('./alias');\nvar assert = require('assert');\nvar sliced = require('sliced');\nvar util   = require('util');\nvar valueExpressionMixin = require('./valueExpression');\n\nvar Node            = require('./');\nvar Select          = require('./select');\nvar From            = require('./from');\nvar Where           = require('./where');\nvar OrderBy         = require('./orderBy');\nvar GroupBy         = require('./groupBy');\nvar Having          = require('./having');\nvar Insert          = require('./insert');\nvar Update          = require('./update');\nvar Delete          = require('./delete');\nvar Returning       = require('./returning');\nvar OnDuplicate     = require('./onDuplicate');\nvar OnConflict      = require('./onConflict');\nvar ForUpdate       = require('./forUpdate');\nvar ForShare        = require('./forShare');\nvar Create          = require('./create');\nvar Drop            = require('./drop');\nvar Truncate        = require('./truncate');\nvar Distinct        = require('./distinct');\nvar DistinctOn      = require('./distinctOn');\nvar Alter           = require('./alter');\nvar AddColumn       = require('./addColumn');\nvar DropColumn      = require('./dropColumn');\nvar RenameColumn    = require('./renameColumn');\nvar Rename          = require('./rename');\nvar Column          = require('../column');\nvar ParameterNode   = require('./parameter');\nvar PrefixUnaryNode = require('./prefixUnary');\nvar IfExists        = require('./ifExists');\nvar IfNotExists     = require('./ifNotExists');\nvar OrIgnore        = require('./orIgnore');\nvar Cascade         = require('./cascade');\nvar Restrict        = require('./restrict');\nvar Indexes         = require('./indexes');\nvar CreateIndex     = require('./createIndex');\nvar DropIndex       = require('./dropIndex');\nvar Table           = require('./table');\nvar CreateView     = require('./createView');\nvar JoinNode        = require('./join');\n\nvar Modifier = Node.define({\n  constructor: function(table, type, count) {\n    this.table = table;\n    this.type = type;\n    this.count = count;\n  }\n});\n\n// get the first element of an arguments if it is an array, else return arguments as an array\nvar getArrayOrArgsAsArray = function(args) {\n  if (util.isArray(args[0])) {\n    return args[0];\n  }\n  return sliced(args);\n};\n\nvar Query = Node.define({\n  type: 'QUERY',\n\n  constructor: function(table) {\n    Node.call(this);\n    this.table = table;\n    if (table) {\n      this.sql = table.sql;\n    }\n  },\n\n  select: function() {\n    var select;\n    if (this._select) {\n      select = this._select;\n    } else {\n      select = this._select = new Select();\n      this.add(select);\n    }\n\n    //allow things like .select(a.star(), [ a.id, a.name ])\n    //this will flatten them into a single array\n    var args = sliced(arguments).reduce(function(cur, next) {\n      if (util.isArray(next)) {\n        return cur.concat(next);\n      }\n\n      cur.push(next);\n      return cur;\n    }, []);\n\n    select.addAll(args);\n\n    // if this is a subquery then add reference to this column\n    if (this.type === 'SUBQUERY') {\n      for (var j = 0; j < select.nodes.length; j++) {\n        var name = select.nodes[j].alias || select.nodes[j].name;\n        var col = new Column(select.nodes[j]);\n        col.name = name;\n        col.property = name;\n        col.table = this;\n        if (this[name] === undefined) {\n          this[name] = col;\n        }\n      }\n    }\n    return this;\n  },\n\n  star: function() {\n    assert(this.type === 'SUBQUERY', 'star() can only be used on a subQuery');\n    return new Column({\n      table: this,\n      star: true\n    });\n  },\n\n  from: function() {\n    var tableNodes = arguments;\n\n    if (Array.isArray(arguments[0])) {\n      tableNodes = arguments[0];\n    }\n\n    for (var i=0; i<tableNodes.length; i++) {\n      this.add(new From().add(tableNodes[i]));\n    }\n\n    return this;\n  },\n\n  leftJoin: function(other) {\n    assert(this.type === 'SUBQUERY', 'leftJoin() can only be used on a subQuery');\n    return new JoinNode('LEFT', this, other.toNode());\n  },\n\n  where: function(node) {\n    if (arguments.length > 1) {\n      // allow multiple where clause arguments\n      var args = sliced(arguments);\n      for (var i = 0; i < args.length; i++) {\n        this.where(args[i]);\n      }\n      return this;\n    }\n    // calling #where twice functions like calling #where & then #and\n    if (this.whereClause) {\n      return this.and(node);\n    }\n    this.whereClause = new Where(this.table);\n    this.whereClause.add(node);\n    return this.add(this.whereClause);\n  },\n\n  or: function(node) {\n    if (!this.whereClause) return this.where(node);\n    this.whereClause.or(node);\n    return this;\n  },\n\n  and: function(node) {\n    if (!this.whereClause) return this.where(node);\n    this.whereClause.and(node);\n    return this;\n  },\n\n  order: function() {\n    var args = getArrayOrArgsAsArray(arguments);\n    var orderBy;\n    if (this._orderBy) {\n      orderBy = this._orderBy;\n    } else {\n      orderBy = this._orderBy = new OrderBy();\n      this.add(orderBy);\n    }\n    orderBy.addAll(args);\n    return this;\n  },\n\n  group: function() {\n    var args = getArrayOrArgsAsArray(arguments);\n    var groupBy = new GroupBy().addAll(args);\n    return this.add(groupBy);\n  },\n\n  having: function() {\n    var args = getArrayOrArgsAsArray(arguments);\n    var having = new Having().addAll(args);\n    return this.add(having);\n  },\n\n  insert: function(o) {\n    var self = this;\n\n    var args = sliced(arguments);\n    // object literal\n    if (arguments.length === 1 && !o.toNode && !o.forEach) {\n      args = [];\n      Object.keys(o).forEach(function(key) {\n        var col = self.table.get(key);\n        if(col && !col.autoGenerated)\n          args.push(col.value(o[key]));\n      });\n    } else if (o.forEach) {\n      o.forEach(function(arg) {\n        return self.insert.call(self, arg);\n      });\n      return self;\n    }\n\n    if (self.insertClause) {\n      self.insertClause.add(args);\n      return self;\n    } else {\n      self.insertClause = new Insert();\n      self.insertClause.add(args);\n      return self.add(self.insertClause);\n    }\n\n  },\n\n  update: function(o) {\n    var self = this;\n    var update = new Update();\n    Object.keys(o).forEach(function(key) {\n      var col = self.table.get(key);\n      if(col && !col.autoGenerated) {\n        var val = o[key];\n        update.add(col.value(ParameterNode.getNodeOrParameterNode(val)));\n      }\n    });\n    return this.add(update);\n  },\n\n  parameter: function(v) {\n    var param = ParameterNode.getNodeOrParameterNode(v);\n    param.isExplicit = true;\n    return this.add(param);\n  },\n\n  delete: function(params) {\n    var result;\n    if (params) {\n      var TableDefinition = require('../table');\n      if (params instanceof TableDefinition || Array.isArray(params)) {\n        //handle explicit delete queries:\n        // e.g. post.delete(post).from(post) -> DELETE post FROM post\n        // e.g. post.delete([post, user]).from(post) -> DELETE post, user FROM post\n        if (Array.isArray(params)) {\n          params = params.map(function(table) { return new Table(table); });\n        } else {\n          params = [ new Table(params) ];\n        }\n        result = this.add(new Delete().addAll(params));\n      } else {\n        //syntax sugar for post.delete().from(post).where(params)\n        result = this.add(new Delete()).where(params);\n      }\n    } else{\n      result = this.add(new Delete());\n    }\n    return result;\n  },\n\n  returning: function() {\n    var returning = new Returning();\n    if (arguments.length === 0)\n      returning.add('*');\n    else\n      returning.addAll(getArrayOrArgsAsArray(arguments));\n\n    return this.add(returning);\n  },\n\n  onDuplicate: function(o) {\n    var self = this;\n\n    var onDuplicate = new OnDuplicate();\n    Object.keys(o).forEach(function(key) {\n      var col = self.table.get(key);\n      if(col && !col.autoGenerated)\n        var val = o[key];\n        onDuplicate.add(col.value(ParameterNode.getNodeOrParameterNode(val))); // jshint ignore:line\n    });\n\n    return self.add(onDuplicate);\n  },\n\n  onConflict: function(o) {\n    var self = this;\n\n    var onConflict = new OnConflict();\n    Object.keys(o).forEach(function(key) {\n        onConflict[key] = o[key];\n    });\n    return self.add(onConflict);\n  },\n\n  forUpdate: function() {\n    assert(typeof this._select !== 'undefined', 'FOR UPDATE can be used only in a select statement');\n    this.add(new ForUpdate());\n    return this;\n  },\n\n  forShare: function() {\n    assert(typeof this._select !== 'undefined', 'FOR SHARE can be used only in a select statement');\n    this.add(new ForShare());\n    return this;\n  },\n\n  create: function(indexName) {\n    if (this.indexesClause) {\n      var createIndex = new CreateIndex(this.table, indexName);\n      this.add(createIndex);\n      return createIndex;\n    } else {\n      return this.add(new Create(this.table.isTemporary));\n    }\n  },\n\n  drop: function() {\n    if (this.indexesClause) {\n      var args = sliced(arguments);\n      var dropIndex = new DropIndex(this.table, args);\n      this.add(dropIndex);\n      return dropIndex;\n    } else {\n      return this.add(new Drop(this.table));\n    }\n  },\n\n  truncate: function() {\n    return this.add(new Truncate(this.table));\n  },\n\n  distinct: function() {\n    return this.add(new Distinct());\n  },\n\n  distinctOn: function() {\n    var distinctOn;\n    if (this._distinctOn) {\n      distinctOn = this._distinctOn;\n    } else {\n      var select = this.nodes.filter(function (node) {return node.type === 'SELECT';}).shift();\n\n      distinctOn = this._distinctOn = new DistinctOn();\n      select.add(distinctOn);\n    }\n\n    //allow things like .distinctOn(a.star(), [ a.id, a.name ])\n    //this will flatten them into a single array\n    var args = sliced(arguments).reduce(function(cur, next) {\n      if (util.isArray(next)) {\n        return cur.concat(next);\n      }\n\n      cur.push(next);\n      return cur;\n    }, []);\n\n    distinctOn.addAll(args);\n\n    return this;\n  },\n\n  alter: function() {\n    return this.add(new Alter());\n  },\n\n  rename: function(newName) {\n    var renameClause = new Rename();\n    if (!newName.toNode) {\n      newName = new Column({\n        name: newName,\n        table: this.table\n      });\n    }\n    renameClause.add(newName.toNode());\n    this.nodes[0].add(renameClause);\n    return this;\n  },\n\n  addColumn: function(column, dataType) {\n    var addClause = new AddColumn();\n    if (!column.toNode) {\n      column = new Column({\n        name: column,\n        table: this.table\n      });\n    }\n    if (dataType) {\n      column.dataType = dataType;\n    }\n    addClause.add(column.toNode());\n    this.nodes[0].add(addClause);\n    return this;\n  },\n\n  dropColumn: function(column) {\n    var dropClause = new DropColumn();\n    if (!column.toNode) {\n      column = new Column({\n        name: column,\n        table: this.table\n      });\n    }\n    dropClause.add(column.toNode());\n    this.nodes[0].add(dropClause);\n    return this;\n  },\n\n  renameColumn: function(oldColumn, newColumn) {\n    var renameClause = new RenameColumn();\n    if (!oldColumn.toNode) {\n      oldColumn = new Column({\n        name: oldColumn,\n        table: this.table\n      });\n    }\n    if (!newColumn.toNode) {\n      newColumn = new Column({\n        name: newColumn,\n        table: this.table\n      });\n    }\n    renameClause.add(oldColumn.toNode());\n    renameClause.add(newColumn.toNode());\n    this.nodes[0].add(renameClause);\n    return this;\n  },\n\n  limit: function(count) {\n    return this.add(new Modifier(this, 'LIMIT', count));\n  },\n\n  offset: function(count) {\n    return this.add(new Modifier(this, 'OFFSET', count));\n  },\n\n  exists: function() {\n    assert(this.type === 'SUBQUERY', 'exists() can only be used on a subQuery');\n    return new PrefixUnaryNode({\n      left: this,\n      operator: \"EXISTS\"\n    });\n  },\n\n  notExists: function() {\n    assert(this.type === 'SUBQUERY', 'notExists() can only be used on a subQuery');\n    return new PrefixUnaryNode({\n      left: this,\n      operator: \"NOT EXISTS\"\n    });\n  },\n\n  ifExists: function() {\n    this.nodes[0].unshift(new IfExists());\n    return this;\n  },\n\n  ifNotExists: function() {\n    this.nodes[0].unshift(new IfNotExists());\n    return this;\n  },\n\n  orIgnore: function() {\n    this.nodes[0].unshift(new OrIgnore());\n    return this;\n  },\n\n  cascade: function() {\n    this.nodes[0].add(new Cascade());\n    return this;\n  },\n\n  restrict: function() {\n    this.nodes[0].add(new Restrict());\n    return this;\n  },\n\n  indexes: function() {\n    this.indexesClause = new Indexes({\n      table: this.table\n    });\n    return this.add(this.indexesClause);\n  },\n\n  createView: function(viewName) {\n    this.add(new CreateView(viewName));\n    return this;\n  }\n});\n\n// Here we are extending query with valueExpressions so that it's possible to write queries like\n//   var query=sql.select(a.select(a.x.sum()).plus(b.select(b.y.sum()))\n// which generates:\n//   SELECT (SELECT SUM(a.x) FROM a) + (SELECT SUM(b.y) FROM b)\n// We need to remove \"or\" and \"and\" from here because it conflicts with the already existing functionality of appending\n// to the where clause like so:\n//   var query=a.select().where(a.name.equals(\"joe\")).or(a.name.equals(\"sam\"))\nvar valueExpressions=valueExpressionMixin();\ndelete valueExpressions.or;\ndelete valueExpressions.and;\n_.extend(Query.prototype, valueExpressions);\n\n// Extend the query with the aliasMixin so that it's possible to write queries like\n//   var query=sql.select(a.select(a.count()).as(\"column1\"))\n// which generates:\n//   SELECT (SELECT COUNT(*) FROM a) AS \"column1\"\n_.extend(Query.prototype, alias.AliasMixin);\n\nmodule.exports = Query;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/select.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'SELECT',\n  constructor: function(arg) {\n    Node.call(this);\n    if (arg && arg.sql) { \n        this.sql = arg.sql;\n    }\n    // used when processing LIMIT clauses in MSSQL\n    this.msSQLLimitNode = undefined;\n    // set to true when a DISTINCT is used on the entire result set\n    this.isDistinct = false;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/from.js":"'use strict';\n\nvar Node = require('./index');\n\nvar From = Node.define({\n  type: 'FROM'\n});\n\nmodule.exports = From;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/where.js":"'use strict';\n\nvar Node = require('./index');\nvar BinaryNode = require('./binary');\nvar TextNode = require('./text');\n\nvar normalizeNode = function(table, node) {\n  var result = node;\n  if(typeof node === 'string') {\n    result = new TextNode('(' + node + ')');\n  }\n  else if (Array.isArray(node)) {\n    result = false;\n\n    if (node.length === 0) {\n      result = new TextNode('(1 = 1)');\n    } else {\n      node.forEach(function (subNode) {\n        if (!result) {\n          result = subNode;\n        } else {\n          result = result.and(subNode);\n        }\n      });\n    }\n  }\n  else if (!node.toNode && typeof node === 'object'){\n    result = false;\n    for (var colName in node) {\n      if (node.hasOwnProperty(colName)) {\n        var column = table.getColumn(colName);\n        var query = column.equals(node[colName]);\n        if (!result) {\n          result = query;\n        } else {\n          result = result.and(query);\n        }\n      }\n    }\n  }\n  return result;\n};\n\nmodule.exports = Node.define({\n  constructor: function(table) {\n    Node.call(this);\n    this.table = table;\n  },\n  type: 'WHERE',\n  add: function(node) {\n    node = normalizeNode(this.table, node);\n    return Node.prototype.add.call(this, node);\n  },\n  or: function(other) {\n    var right = normalizeNode(this.table, other);\n    // calling 'or' without an initial 'where'\n    if(!this.nodes.length) {\n      return this.add(other);\n    }\n    return this.nodes.push(new BinaryNode({\n      left: this.nodes.pop(),\n      operator: 'OR',\n      right: right\n    }));\n  },\n  and: function(other) {\n    var right = normalizeNode(this.table, other);\n    return this.nodes.push(new BinaryNode({\n      left: this.nodes.pop(),\n      operator: 'AND',\n      right: right\n    }));\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/orderBy.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'ORDER BY'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/groupBy.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'GROUP BY'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/having.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'HAVING'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/insert.js":"'use strict';\n\nvar DefaultNode   = require('./default');\nvar Node          = require('./');\nvar ParameterNode = require('./parameter');\n\nvar Insert = Node.define({\n  type: 'INSERT',\n  constructor: function () {\n    Node.call(this);\n    this.names = [];\n    this.columns = [];\n    this.valueSets = [];\n  }\n});\n\nmodule.exports = Insert;\n\nInsert.prototype.add = function (nodes) {\n  var hasColumns = false;\n  var hasValues = false;\n  var self = this;\n  var values = {};\n  nodes.forEach(function (node) {\n    var column = node.toNode();\n    var name = column.name;\n    var idx = self.names.indexOf(name);\n    if (idx < 0) {\n      self.names.push(name);\n      self.columns.push(column);\n    }\n    hasColumns = true;\n    hasValues = hasValues || column.value !== undefined;\n    values[name] = column;\n  });\n\n  // When none of the columns have a value, it's ambiguous whether the user\n  // intends to insert a row of default values or append a SELECT statement\n  // later.  Resolve the ambiguity by assuming that if no columns are specified\n  // it is a row of default values, otherwise a SELECT will be added.\n  if (hasValues || !hasColumns) {\n    this.valueSets.push(values);\n  }\n\n  return self;\n};\n\n/*\n * Get parameters for all values to be inserted. This function\n * handles handles bulk inserts, where keys may be present\n * in some objects and not others. When keys are not present,\n * the insert should refer to the column value as DEFAULT.\n */\nInsert.prototype.getParameters = function () {\n  var self = this;\n  return this.valueSets\n    .map(function (nodeDict) {\n      var set = [];\n      self.names.forEach(function (name) {\n        var node = nodeDict[name];\n        if (node) {\n          set.push(ParameterNode.getNodeOrParameterNode(node.value));\n        }\n        else {\n          set.push(new DefaultNode());\n        }\n      });\n      return set;\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/default.js":"'use strict';\n\nmodule.exports = require('./index').define({\n  type: 'DEFAULT',\n  value: function() {\n    return;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/update.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'UPDATE'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/delete.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'DELETE'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/returning.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'RETURNING'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/onDuplicate.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'ONDUPLICATE'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/onConflict.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'ONCONFLICT'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/forUpdate.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'FOR UPDATE'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/forShare.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'FOR SHARE'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/create.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'CREATE',\n\n  constructor: function(isTemporary) {\n    Node.call(this);\n\n    this.options = { isTemporary: isTemporary};\n  },\n\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/drop.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'DROP',\n\n  constructor: function(table) {\n    Node.call(this);\n    this.add(table);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/truncate.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'TRUNCATE',\n\n  constructor: function(table) {\n    Node.call(this);\n    this.add(table);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/distinct.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'DISTINCT',\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/distinctOn.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'DISTINCT ON',\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/alter.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'ALTER'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/addColumn.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'ADD COLUMN'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/dropColumn.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'DROP COLUMN'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/renameColumn.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'RENAME COLUMN'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/rename.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'RENAME'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/prefixUnary.js":"'use strict';\n\nvar _                    = require('lodash');\nvar Node                 = require('./index');\nvar valueExpressionMixin = require('./valueExpression');\n\nvar valueExpressionMixed = false;\nvar PrefixUnaryNode = Node.define({\n  type: 'PREFIX UNARY',\n  constructor: function(config) {\n    Node.call(this);\n    this.left = config.left;\n    this.operator = config.operator;\n\n    // Delay mixin to runtime, when all nodes have been defined, and\n    // mixin only once. ValueExpressionMixin has circular dependencies.\n    if (!valueExpressionMixed) {\n      valueExpressionMixed = true;\n      _.extend(PrefixUnaryNode.prototype, valueExpressionMixin());\n    }\n  }\n});\n\n// allow aliasing\nvar AliasNode = require('./alias');\n_.extend(PrefixUnaryNode.prototype, AliasNode.AliasMixin);\n\nmodule.exports = PrefixUnaryNode;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/ifExists.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'IF EXISTS'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/ifNotExists.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'IF NOT EXISTS'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/orIgnore.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'OR IGNORE'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/cascade.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'CASCADE'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/restrict.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'RESTRICT'\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/indexes.js":"'use strict';\n\nvar Node = require('./');\n\nvar IndexesNode  = Node.define({\n  type: 'INDEXES',\n\n  constructor: function(table) {\n    Node.call(this);\n\n    this.table = table;\n  }\n});\n\nmodule.exports = IndexesNode;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/createIndex.js":"'use strict';\n\nvar Node   = require('./');\nvar sliced = require('sliced');\n\nmodule.exports = Node.define({\n  type: 'CREATE INDEX',\n\n  constructor: function(table, indexName) {\n    Node.call(this);\n\n    this.table   = table;\n    this.options = { indexName: indexName, columns: [] };\n  },\n\n  unique: function() {\n    this.options.type = 'unique';\n    return this;\n  },\n\n  spatial: function() {\n    this.options.type = 'spatial';\n    return this;\n  },\n\n  fulltext: function() {\n    this.options.type = 'fulltext';\n    return this;\n  },\n\n  using: function(algorithm) {\n    this.options.algorithm = algorithm;\n    return this;\n  },\n\n  on: function() {\n    var args = sliced(arguments);\n    this.options.columns = this.options.columns.concat(args);\n    return this;\n  },\n\n  withParser: function(parser) {\n    this.options.parser = parser;\n    return this;\n  },\n\n  indexName: function() {\n    var result = this.options.indexName;\n\n    if (!result) {\n      var columns = this.options.columns.map(function(col) {\n        var column = col.name ? col.name : col.value.name;\n        return column;\n      }).sort();\n\n      result = [this.table._name];\n      result = result.concat(columns);\n      result = result.join('_');\n    }\n\n    return result;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/dropIndex.js":"'use strict';\n\nvar Node = require('./');\n\nmodule.exports = Node.define({\n  type: 'DROP INDEX',\n\n  constructor: function(table, indexName) {\n    if (!indexName) {\n      throw new Error('No index defined!');\n    } else if (Array.isArray(indexName) && (typeof indexName[0] === 'string')) {\n      indexName = indexName[0];\n    } else if (Array.isArray(indexName)) {\n      var columns = indexName.map(function(col) { return col.name; }).sort();\n      indexName = [table._name].concat(columns).join('_');\n    }\n\n    Node.call(this);\n\n    this.table   = table;\n    this.options = { indexName: indexName };\n  },\n\n  indexName: function() {\n    var result = this.options.indexName;\n\n    if (!result) {\n      var columns = this.options.columns.map(function(col) {\n        return col.name;\n      }).sort();\n\n      result = [this.table._name];\n      result = result.concat(columns);\n      result = result.join('_');\n    }\n\n    return result;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/table.js":"'use strict';\n\nvar Node = require('./index');\nmodule.exports = Node.define({\n  type: 'TABLE',\n  constructor: function(table) {\n    Node.call(this);\n    this.table = table;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/createView.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'CREATE VIEW',\n\n  constructor: function(viewName) {\n    Node.call(this);\n\n    this.options = { viewName: viewName};\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/join.js":"'use strict';\n\nvar Node = require('./index');\nvar JoinNode = module.exports = Node.define({\n  type: 'JOIN',\n  constructor: function(subType, from, to) {\n    Node.call(this);\n    this.sql = (from.table && from.table.sql) || (to.table && to.table.sql);\n    this.subType = subType;\n    this.from = from.toNode();\n    this.to = to.toNode();\n  },\n  on: function(node) {\n    this.on = node;\n    return this;\n  },\n  join: function(other) {\n    return new JoinNode('INNER', this, other);\n  },\n  leftJoin: function(other) {\n    return new JoinNode('LEFT', this, other);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/table.js":"'use strict';\n\nvar util = require('util');\nvar lodash = require('lodash');\n\nvar Query = require('./node/query');\nvar Column = require('./column');\nvar TableNode = require('./node/table');\nvar JoinNode = require('./node/join');\nvar LiteralNode = require('./node/literal');\nvar Joiner = require('./joiner');\nvar ForeignKeyNode = require('./node/foreignKey');\n\nvar Table = function(config) {\n  this._schema = config.schema;\n  this._name = config.name;\n  this._initialConfig = config;\n  this.columnWhiteList = !!config.columnWhiteList;\n  this.isTemporary=!!config.isTemporary;\n  this.snakeToCamel = !!config.snakeToCamel;\n  this.columns = [];\n  this.foreignKeys = [];\n  this.table = this;\n  if (!config.sql) {\n    config.sql = require('./index');\n  }\n  this.sql = config.sql;\n};\n\nTable.define = function(config) {\n  var table = new Table(config);\n  // allow hash of columns as well as array\n  if (config.columns && !util.isArray(config.columns)) {\n    var cols = [];\n\n    for (var key in config.columns) {\n      if (config.columns.hasOwnProperty(key)) {\n        var col = config.columns[key];\n        col.name = key;\n        cols.push(col);\n      }\n    }\n\n    config.columns = cols;\n  }\n\n  for (var i = 0; i < config.columns.length; i++) {\n    table.addColumn(config.columns[i]);\n  }\n\n  if(config.foreignKeys !== undefined) {\n    if(util.isArray(config.foreignKeys)) {\n      for(i = 0; i < config.foreignKeys.length; i++) {\n        table.foreignKeys.push(new ForeignKeyNode(config.foreignKeys[i]));\n      }\n    } else {\n      table.foreignKeys.push(new ForeignKeyNode(config.foreignKeys));\n    }\n  }\n  return table;\n};\n\nTable.prototype.clone = function(config) {\n  return Table.define(lodash.extend({\n    schema: this._schema,\n    name: this._name,\n    sql: this.sql,\n    columnWhiteList: !!this.columnWhiteList,\n    snakeToCamel: !!this.snakeToCamel,\n    columns: this.columns,\n    foreignKeys: this.foreignKeys\n  }, config || {}));\n};\n\nTable.prototype.createColumn = function(col) {\n  if(!(col instanceof Column)) {\n    if(typeof col === 'string') {\n      col = { name: col };\n    }\n\n    col.table = this;\n    col = new Column(col);\n\n    // Load subfields from array into an object of form name: Column\n    if(util.isArray(col.subfields)) {\n      col.subfields = lodash.chain(col.subfields)\n        .map(lodash.bind(function (subfield) {\n          return [subfield, new Column({\n            table: this,\n            subfieldContainer: col,\n            name: subfield\n          })];\n        }, this))\n        .fromPairs()\n        .value();\n    }\n  }\n\n  return col;\n};\n\nTable.prototype.addColumn = function(col, options) {\n  col     = this.createColumn(col);\n  options = lodash.extend({\n    noisy: true\n  }, options || {});\n\n  if(this.hasColumn(col)) {\n    if (options.noisy) {\n      throw new Error('Table ' + this._name + ' already has column or property by the name of ' + col.name);\n    } else {\n      return this;\n    }\n  } else if(!!this[col.name] && (process.env.NODE_ENV === 'debug')) {\n    console.log('Please notice that you have just defined the column \"' + col.name + '\". In order to access it, you need to use \"table.getColumn(\\'' + col.name + '\\');\"!');\n  }\n  this.columns.push(col);\n\n  function snakeToCamel(snakeName) {\n    return snakeName.replace(/[\\-_]([a-z])/g, function(m, $1){ return $1.toUpperCase(); });\n  }\n\n  var property = col.property = col.property || (this.snakeToCamel ? snakeToCamel(col.name) : col.name);\n  this[property] = this[property] || col;\n  return this;\n};\n\nTable.prototype.hasColumn = function(col) {\n  var columnName = col instanceof Column ? col.name : col;\n  return this.columns.some(function(column) {\n    return column.property === columnName || column.name === columnName;\n  });\n};\n\nTable.prototype.getColumn =\nTable.prototype.get =\nfunction(colName) {\n  for(var i = 0; i < this.columns.length; i++) {\n    var col = this.columns[i];\n    if (colName === col.property || colName === col.name) {\n      return col;\n    }\n  }\n  if(this.columnWhiteList)\n    return null;\n  throw new Error('Table ' + this._name + ' does not have a column or property named ' + colName);\n};\n\nTable.prototype.getSchema = function() {\n  return this._schema;\n};\n\nTable.prototype.setSchema = function(schema) {\n  this._schema = schema;\n};\n\nTable.prototype.getName = function() {\n  if (this.sql && this.sql.dialectName==\"mssql\" && this.isTemporary) return \"#\"+this._name;\n  return this._name;\n};\n\nTable.prototype.star = function(options) {\n  options = options || {};\n  if (options.prefix) {\n    return this.columns.map(function(column) {\n      return this[column.name].as(options.prefix + column.name);\n    }.bind(this));\n  }\n\n  return new Column({table: this, star: true});\n};\n\nTable.prototype.literal = function(literal) {\n  return new LiteralNode(literal);\n};\n\nTable.prototype.count = function(alias) {\n  var name = this.alias || this._name,\n    col = new Column({table: this, star: true});\n  // ColumnNode\n  return col.count(alias || name + '_count');\n};\n\nTable.prototype.select = function() {\n  // create the query and pass it off\n  var query = new Query(this);\n  if (arguments.length === 0) {\n    query.select.call(query, this.star());\n  } else {\n    query.select.apply(query, arguments);\n  }\n  return query;\n};\n\nTable.prototype.subQuery = function(alias) {\n  // create the query and pass it off\n  var query = new Query(this);\n  query.type = 'SUBQUERY';\n  query.alias = alias;\n  query.join = function(other) {\n    return new JoinNode('INNER', this.toNode(), other.toNode(), other);\n  };\n  return query;\n};\n\nTable.prototype.insert = function() {\n  var query = new Query(this);\n  if(!arguments[0] || (util.isArray(arguments[0]) && arguments[0].length === 0)){\n    query.select.call(query, this.star());\n    query.where.apply(query,[\"1=2\"]);\n  } else {\n    query.insert.apply(query, arguments);\n  }\n  return query;\n};\n\nTable.prototype.toNode = function() {\n  return new TableNode(this);\n};\n\nTable.prototype.join = function(other) {\n  return new JoinNode('INNER', this.toNode(), other.toNode(), other);\n};\n\nTable.prototype.leftJoin = function(other) {\n  return new JoinNode('LEFT', this.toNode(), other.toNode());\n};\n\n// auto-join tables based on column intropsection\nTable.prototype.joinTo = function(other) {\n  return Joiner.leftJoin(this, other);\n};\n\nTable.prototype.as = function(alias) {\n  // TODO could this be cleaner?\n  var t = Table.define(this._initialConfig);\n  t.alias = alias;\n  return t;\n};\n\n// called in shorthand when not calling select\nTable.prototype.__defineGetter__(\"nodes\", function() {\n  return this.select(this.star()).nodes;\n});\n\nTable.prototype.and = function() {\n  var query = new Query(this);\n  query.where.apply(query, arguments);\n  return query;\n};\n\nTable.prototype.indexes = function() {\n  return new Query(this).indexes();\n};\n\nvar queryMethods = [\n  'alter',\n  'create',\n  'delete',\n  'drop',\n  'from',\n  'limit',\n  'offset',\n  'or',\n  'order',\n  'truncate',\n  'update',\n  'where'\n];\n\nqueryMethods.forEach(function (method) {\n  Table.prototype[method] = function () {\n    var query = new Query(this);\n    query[method].apply(query, arguments);\n    return query;\n  };\n});\n\nmodule.exports = Table;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/literal.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'LITERAL',\n  constructor: function(literal) {\n    Node.call(this);\n    this.literal = literal;\n    this.alias = null;\n  },\n  as: function(alias) {\n    this.alias = alias;\n    return this;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/joiner.js":"'use strict';\n\nvar getPrimaryKeyColumn = function(table) {\n  for (var i = 0; i < table.columns.length; i++) {\n    var col = table.columns[i];\n    if (col.primaryKey) {\n      return col;\n    }\n  }\n};\n\nvar findReference = function(left, right) {\n  // find reference\n  for (var i = 0; i < right.columns.length; i++) {\n    var col = right.columns[i];\n    if (col.references) {\n      var leftName = left.getName();\n      if (col.references === leftName || col.references.table === leftName) {\n        var leftCol = left[col.references.column] || getPrimaryKeyColumn(left);\n        return {\n          left: leftCol,\n          right: col\n        };\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  // auto-join two tables based on column properties\n  // requires one column to have { references: {table: 'foreignTableName', column: 'foreignColumnName'}}\n  // or to have { references: 'foreignTableName'} -- in which case the foreign table's primary key is assumed\n  leftJoin: function(left, right) {\n    var ref = findReference(left, right);\n    if (!ref) {\n      ref = findReference(right, left);\n    }\n    return left.join(right).on(ref.left.equals(ref.right));\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/foreignKey.js":"'use strict';\n\nvar Node = require('./index');\n\nmodule.exports = Node.define({\n  type: 'FOREIGN KEY',\n  constructor: function(config) {\n    Node.call(this);\n    this.name = config.name;\n    this.columns = config.columns;\n    this.schema = config.schema;\n    this.table = config.table;\n    this.refColumns = config.refColumns;\n    this.onUpdate = config.onUpdate;\n    this.onDelete = config.onDelete;\n    this.constraint = config.constraint;\n  }\n});\n\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/node/interval.js":"'use strict';\n\nvar Node          = require('./index');\nvar ParameterNode = require('./parameter');\n\nvar IntervalNode = Node.define({\n  type: 'INTERVAL',\n  constructor: function(args) {\n    Node.call(this);\n    var interval = args[0] || {};\n    this.years = interval.years;\n    this.months = interval.months;\n    this.days = interval.days;\n    this.hours = interval.hours;\n    this.minutes = interval.minutes;\n    this.seconds = interval.seconds;\n  }\n});\n\nmodule.exports = IntervalNode;\n\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/lib/dialect/postgres.js":"'use strict';\n\nvar _      = require('lodash');\nvar assert = require('assert');\nvar From   = require('../node/from');\nvar Select = require('../node/select');\nvar Table  = require('../table');\n\nvar Postgres = function(config) {\n  this.output = [];\n  this.params = [];\n  this.config = config || {};\n};\n\nPostgres.prototype._myClass = Postgres;\n\nPostgres.prototype._arrayAggFunctionName = 'array_agg';\n\nPostgres.prototype._getParameterText = function(index, value) {\n  if (this._disableParameterPlaceholders) {\n    // do not use placeholder\n    return this._getParameterValue(value);\n  } else {\n    // use placeholder\n    return this._getParameterPlaceholder(index, value);\n  }\n};\n\nPostgres.prototype._getParameterValue = function(value, quoteChar) {\n  // handle primitives\n  if (null === value) {\n    value = 'NULL';\n  } else if ('boolean' === typeof value) {\n    value = value ? 'TRUE' : 'FALSE';\n  } else if ('number' === typeof value) {\n    // number is just number\n    value = value;\n  } else if ('string' === typeof value) {\n    // string uses single quote by default\n    value = this.quote(value, quoteChar || \"'\");\n  } else if ('object' === typeof value) {\n    if (Array.isArray(value)) {\n      if (this._myClass === Postgres) {\n        // naive check to see if this is an array of objects, which\n        // is handled differently than an array of primitives\n        if (value.length && 'object' === typeof value[0] &&\n            !_.isFunction(value[0].toISOString) &&\n            !Array.isArray(value[0])) {\n            value = \"'\" + JSON.stringify(value) + \"'\";\n        } else {\n            var self = this;\n            value = value.map(function (item) {\n                // In a Postgres array, strings must be double-quoted\n                return self._getParameterValue(item, '\"');\n            });\n            value = '\\'{' + value.join(',') + '}\\'';\n        }\n      } else {\n        value = _.map(value, this._getParameterValue.bind(this));\n        value = '(' + value.join(', ') + ')';\n      }\n    } else if (value instanceof Date) {\n      // Date object's default toString format does not get parsed well\n      // Handle dates using toISOString\n      value = this._getParameterValue(value.toISOString());\n    } else if (Buffer.isBuffer(value)) {\n      value = this._getParameterValue('\\\\x' + value.toString('hex'));\n    } else {\n      // rich object represent with string\n      var strValue = value.toString();\n      value = strValue === '[object Object]' ? this._getParameterValue(JSON.stringify(value)) : this._getParameterValue(strValue);\n    }\n  } else {\n    throw new Error('Unable to use ' + value + ' in query');\n  }\n\n  // value has been converted at this point\n  return value;\n};\n\nPostgres.prototype._getParameterPlaceholder = function(index, value) {\n  /* jshint unused: false */\n  return '$' + index;\n};\n\nPostgres.prototype.getQuery = function(queryNode) {\n  // passed in a table, not a query\n  if (queryNode instanceof Table) {\n    queryNode = queryNode.select(queryNode.star());\n  }\n  this.output = this.visit(queryNode);\n\n  //if is a create view, must replace paramaters with values\n  if (this.output.indexOf('CREATE VIEW') > -1) {\n    var previousFlagStatus = this._disableParameterPlaceholders;\n    this._disableParameterPlaceholders = true;\n    this.output = [];\n    this.output = this.visit(queryNode);\n    this.params = [];\n    this._disableParameterPlaceholders = previousFlagStatus;\n  }\n\n  // create the query object\n  var query = { text: this.output.join(' '), values: this.params };\n\n  // reset the internal state of this builder\n  this.output = [];\n  this.params = [];\n\n  return query;\n};\n\nPostgres.prototype.getString = function(queryNode) {\n  // switch off parameter placeholders\n  var previousFlagStatus = this._disableParameterPlaceholders;\n  this._disableParameterPlaceholders = true;\n  var query;\n  try {\n    // use the same code path for query building\n    query = this.getQuery(queryNode);\n  } finally {\n    // always restore the flag afterwards\n    this._disableParameterPlaceholders = previousFlagStatus;\n  }\n  return query.text;\n};\n\nPostgres.prototype.visit = function(node) {\n  switch(node.type) {\n    case 'QUERY'           : return this.visitQuery(node);\n    case 'SUBQUERY'        : return this.visitSubquery(node);\n    case 'SELECT'          : return this.visitSelect(node);\n    case 'INSERT'          : return this.visitInsert(node);\n    case 'UPDATE'          : return this.visitUpdate(node);\n    case 'DELETE'          : return this.visitDelete(node);\n    case 'CREATE'          : return this.visitCreate(node);\n    case 'DROP'            : return this.visitDrop(node);\n    case 'TRUNCATE'        : return this.visitTruncate(node);\n    case 'DISTINCT'        : return this.visitDistinct(node);\n    case 'DISTINCT ON'     : return this.visitDistinctOn(node);\n    case 'ALIAS'           : return this.visitAlias(node);\n    case 'ALTER'           : return this.visitAlter(node);\n    case 'CAST'            : return this.visitCast(node);\n    case 'FROM'            : return this.visitFrom(node);\n    case 'WHERE'           : return this.visitWhere(node);\n    case 'ORDER BY'        : return this.visitOrderBy(node);\n    case 'ORDER BY VALUE'  : return this.visitOrderByValue(node);\n    case 'GROUP BY'        : return this.visitGroupBy(node);\n    case 'HAVING'          : return this.visitHaving(node);\n    case 'RETURNING'       : return this.visitReturning(node);\n    case 'ONDUPLICATE'     : return this.visitOnDuplicate(node);\n    case 'ONCONFLICT'      : return this.visitOnConflict(node);\n    case 'FOR UPDATE'      : return this.visitForUpdate();\n    case 'FOR SHARE'       : return this.visitForShare();\n    case 'TABLE'           : return this.visitTable(node);\n    case 'COLUMN'          : return this.visitColumn(node);\n    case 'FOREIGN KEY'     : return this.visitForeignKey(node);\n    case 'JOIN'            : return this.visitJoin(node);\n    case 'LITERAL'         : return this.visitLiteral(node);\n    case 'TEXT'            : return node.text;\n    case 'PARAMETER'       : return this.visitParameter(node);\n    case 'DEFAULT'         : return this.visitDefault(node);\n    case 'IF EXISTS'       : return this.visitIfExists();\n    case 'IF NOT EXISTS'   : return this.visitIfNotExists();\n    case 'OR IGNORE'       : return this.visitOrIgnore();\n    case 'CASCADE'         : return this.visitCascade();\n    case 'RESTRICT'        : return this.visitRestrict();\n    case 'RENAME'          : return this.visitRename(node);\n    case 'ADD COLUMN'      : return this.visitAddColumn(node);\n    case 'DROP COLUMN'     : return this.visitDropColumn(node);\n    case 'RENAME COLUMN'   : return this.visitRenameColumn(node);\n    case 'INDEXES'         : return this.visitIndexes(node);\n    case 'CREATE INDEX'    : return this.visitCreateIndex(node);\n    case 'DROP INDEX'      : return this.visitDropIndex(node);\n    case 'FUNCTION CALL'   : return this.visitFunctionCall(node);\n    case 'ARRAY CALL'      : return this.visitArrayCall(node);\n    case 'CREATE VIEW'     : return this.visitCreateView(node);\n    case 'INTERVAL'        : return this.visitInterval(node);\n\n    case 'POSTFIX UNARY' : return this.visitPostfixUnary(node);\n    case 'PREFIX UNARY'  : return this.visitPrefixUnary(node);\n    case 'BINARY'        : return this.visitBinary(node);\n    case 'TERNARY'       : return this.visitTernary(node);\n    case 'IN'            : return this.visitIn(node);\n    case 'NOT IN'        : return this.visitNotIn(node);\n    case 'CASE'          : return this.visitCase(node);\n    case 'AT'            : return this.visitAt(node);\n    case 'SLICE'         : return this.visitSlice(node);\n\n    case 'LIMIT' :\n    case 'OFFSET':\n      return this.visitModifier(node);\n    default:\n      throw new Error(\"Unrecognized node type \" + node.type);\n  }\n};\n\nPostgres.prototype._quoteCharacter = '\"';\nPostgres.prototype._aliasText = ' AS ';\n\nPostgres.prototype.quote = function(word, quoteCharacter) {\n  var q;\n  if (quoteCharacter) {\n    // use the specified quote character if given\n    q = quoteCharacter;\n  } else {\n    q = this._quoteCharacter;\n  }\n  // handle square brackets specially\n  if (q=='['){\n    return '['+word+']';\n  } else {\n    return q + word.replace(new RegExp(q,'g'),q+q) + q;\n  }\n};\n\nPostgres.prototype.visitSelect = function(select) {\n  var result = ['SELECT'];\n\n  if (select.isDistinct) result.push('DISTINCT');\n\n  var distinctOnNode = select.nodes.filter(function (node) {return node.type === 'DISTINCT ON';}).shift();\n  var nonDistinctOnNodes = select.nodes.filter(function (node) {return node.type !== 'DISTINCT ON';});\n\n  if (distinctOnNode) {\n    result.push(this.visit(distinctOnNode));\n  }\n\n  result.push(nonDistinctOnNodes.map(this.visit.bind(this)).join(', '));\n\n  this._selectOrDeleteEndIndex = this.output.length + result.length;\n\n  return result;\n};\n\nPostgres.prototype.visitInsert = function(insert) {\n  var self = this;\n  // don't use table.column for inserts\n  this._visitedInsert = true;\n\n  var result = ['INSERT'];\n  result = result.concat(insert.nodes.map(this.visit.bind(this)));\n  result.push('INTO ' + this.visit(this._queryNode.table.toNode()));\n  result.push('(' + insert.columns.map(this.visit.bind(this)).join(', ') + ')');\n\n  var paramNodes = insert.getParameters();\n\n  if (paramNodes.length > 0) {\n    var paramText = paramNodes.map(function (paramSet) {\n        return paramSet.map(function (param) {\n          return self.visit(param);\n        }).join(', ');\n      }).map(function (param) {\n        return '('+param+')';\n      }).join(', ');\n\n    result.push('VALUES', paramText);\n\n    if (result.slice(2, 5).join(' ') === '() VALUES ()') {\n      result.splice(2, 3, 'DEFAULT VALUES');\n    }\n  }\n\n  this._visitedInsert = false;\n\n  return result;\n};\n\nPostgres.prototype.visitUpdate = function(update) {\n  // don't auto-generate from clause\n  var params = [];\n  /* jshint boss: true */\n  for(var i = 0, node; node = update.nodes[i]; i++) {\n    this._visitingUpdateTargetColumn = true;\n    var target_col = this.visit(node);\n    this._visitingUpdateTargetColumn = false;\n    params = params.concat(target_col + ' = ' + this.visit(node.value));\n  }\n  var result = [\n    'UPDATE',\n    this.visit(this._queryNode.table.toNode()),\n    'SET',\n    params.join(', ')\n  ];\n  return result;\n};\n\nPostgres.prototype.visitDelete = function (del) {\n  var result = ['DELETE'];\n  if (del.nodes.length) {\n    result.push(del.nodes.map(this.visit.bind(this)).join(', '));\n  }\n  this._selectOrDeleteEndIndex = result.length;\n  return result;\n};\n\nPostgres.prototype.visitCreate = function(create) {\n  this._visitingCreate = true;\n  // don't auto-generate from clause\n  var table = this._queryNode.table;\n  var col_nodes = table.columns.map(function(col) { return col.toNode(); });\n  var foreign_key_nodes = table.foreignKeys;\n\n   var result = ['CREATE TABLE'];\n  if (create.options.isTemporary) result=['CREATE TEMPORARY TABLE'];\n  result = result.concat(create.nodes.map(this.visit.bind(this)));\n  result.push(this.visit(table.toNode()));\n  var primary_col_nodes = col_nodes.filter(function(n) {\n    return n.primaryKey;\n  });\n  this._visitCreateCompoundPrimaryKey = primary_col_nodes.length > 1;\n  var colspec = '(' + col_nodes.map(this.visit.bind(this)).join(', ');\n  if (this._visitCreateCompoundPrimaryKey) {\n    colspec += ', PRIMARY KEY (';\n    colspec += primary_col_nodes.map(function(node) {\n      return this.quote(node.name);\n    }.bind(this)).join(', ');\n    colspec += ')';\n  }\n  if(foreign_key_nodes.length > 0) {\n    colspec += ', ' + foreign_key_nodes.map(this.visit.bind(this)).join(', ');\n  }\n  colspec += ')';\n  result.push(colspec);\n  this._visitCreateCompoundPrimaryKey = false;\n  this._visitingCreate = false;\n  return result;\n};\n\nPostgres.prototype.visitDrop = function(drop) {\n  // don't auto-generate from clause\n  var result = ['DROP TABLE'];\n  result = result.concat(drop.nodes.map(this.visit.bind(this)));\n  return result;\n};\n\nPostgres.prototype.visitTruncate = function(truncate) {\n  var result = ['TRUNCATE TABLE'];\n  result = result.concat(truncate.nodes.map(this.visit.bind(this)));\n  return result;\n};\n\nPostgres.prototype.visitDistinct = function(truncate) {\n  // Nothing to do here since it's handled in the SELECT clause\n  return [];\n};\n\nPostgres.prototype.visitDistinctOn = function(distinctOn) {\n  return ['DISTINCT ON('+distinctOn.nodes.map(this.visit.bind(this)).join(', ')+')'];\n};\n\nPostgres.prototype.visitAlias = function(alias) {\n  var result = [this.visit(alias.value) + this._aliasText + this.quote(alias.alias)];\n  return result;\n};\n\nPostgres.prototype.visitAlter = function(alter) {\n  this._visitingAlter = true;\n  // don't auto-generate from clause\n  var table = this._queryNode.table;\n  var result = [\n    'ALTER TABLE',\n    this.visit(table.toNode()),\n    alter.nodes.map(this.visit.bind(this)).join(', ')\n  ];\n  this._visitingAlter = false;\n  return result;\n};\n\nPostgres.prototype.visitCast = function(cast) {\n  this._visitingCast = true;\n  var result = ['CAST(' + this.visit(cast.value) + ' AS ' + cast.dataType + ')'];\n  this._visitingCast = false;\n  return result;\n};\n\nPostgres.prototype.visitFrom = function(from) {\n  var result = [];\n  if (from.skipFromStatement) {\n    result.push(',');\n  } else {\n    result.push('FROM');\n  }\n  for(var i = 0; i < from.nodes.length; i++) {\n    result = result.concat(this.visit(from.nodes[i]));\n  }\n  return result;\n};\n\nPostgres.prototype.visitWhere = function(where) {\n  this._visitingWhere = true;\n  var result = ['WHERE', where.nodes.map(this.visit.bind(this)).join(', ')];\n  this._visitingWhere = false;\n  return result;\n};\n\nPostgres.prototype.visitOrderBy = function(orderBy) {\n  var result = ['ORDER BY', orderBy.nodes.map(this.visit.bind(this)).join(', ')];\n  if (this._myClass === Postgres && this.config.nullOrder) {\n      result.push('NULLS ' + this.config.nullOrder.toUpperCase());\n  }\n  return result;\n};\n\nPostgres.prototype.visitOrderByValue = function(orderByValue) {\n  var text = this.visit(orderByValue.value);\n  if (orderByValue.direction) {\n    text += ' ' + this.visit(orderByValue.direction);\n  }\n  return [text];\n};\n\nPostgres.prototype.visitGroupBy = function(groupBy) {\n  var result = ['GROUP BY', groupBy.nodes.map(this.visit.bind(this)).join(', ')];\n  return result;\n};\n\nPostgres.prototype.visitHaving = function(having) {\n  var result = ['HAVING', having.nodes.map(this.visit.bind(this)).join(' AND ')];\n  return result;\n};\n\nPostgres.prototype.visitPrefixUnary = function(unary) {\n  var text = '(' + unary.operator + ' ' + this.visit(unary.left) + ')';\n  return [text];\n};\n\nPostgres.prototype.visitPostfixUnary = function(unary) {\n  var text = '(' + this.visit(unary.left) + ' ' + unary.operator + ')';\n  return [text];\n};\n\nPostgres.prototype.visitBinary = function(binary) {\n  var self = this;\n\n  binary.left.property = binary.left.name;\n  binary.right.property = binary.right.name;\n\n  var text = '(' + this.visit(binary.left) + ' ' + binary.operator + ' ';\n  if (Array.isArray(binary.right)) {\n    text += '(' + binary.right.map(function (node) {\n      return self.visit(node);\n    }).join(', ') + ')';\n  }\n  else {\n    text += this.visit(binary.right);\n  }\n  text += ')';\n  return [text];\n};\n\nPostgres.prototype.visitTernary = function(ternary) {\n  var self = this;\n  var text = '(' + this.visit(ternary.left) + ' ' + ternary.operator + ' ';\n\n  var visitPart = function(value) {\n    var text = '';\n    if (Array.isArray(value)) {\n      text += '(' + value.map(function (node) {\n        return self.visit(node);\n      }).join(', ') + ')';\n    }\n    else {\n      text += self.visit(value);\n    }\n    return text;\n  };\n\n  text += visitPart(ternary.middle);\n  text += ' ' + ternary.separator + ' ';\n  text += visitPart(ternary.right);\n\n  text += ')';\n  return [text];\n};\n\nPostgres.prototype.visitIn = function(binary) {\n  var self = this;\n  var text = '(';\n\n  if (Array.isArray(binary.right)) {\n    if (binary.right.length) {\n      var params  = [];\n      var hasNull = false;\n\n      binary.right.forEach(function(node) {\n        if (node.type === 'PARAMETER' && node._val === null) {\n          hasNull = true;\n        } else {\n          params.push(self.visit(node));\n        }\n      });\n\n      if (params.length) {\n        text += this.visit(binary.left) + ' IN (' + params.join(', ') + ')';\n\n        if (hasNull) {\n          text += ' OR ' + this.visit(binary.left) + ' IS NULL';\n        }\n      } else { // implicitely has null\n        text += this.visit(binary.left) + ' IS NULL';\n      }\n    } else {\n      text += '1=0';\n    }\n  } else {\n    text += this.visit(binary.left) + ' IN ' + this.visit(binary.right);\n  }\n\n  text += ')';\n  return [text];\n};\n\nPostgres.prototype.visitNotIn = function(binary) {\n  var self = this;\n  var text = '(';\n\n  if (Array.isArray(binary.right)) {\n    if (binary.right.length) {\n      var params  = [];\n      var hasNull = false;\n\n      binary.right.forEach(function(node) {\n        if (node.type === 'PARAMETER' && node._val === null) {\n          hasNull = true;\n        } else {\n          params.push(self.visit(node));\n        }\n      });\n\n      if (params.length && hasNull) {\n        text += 'NOT (';\n        text += this.visit(binary.left) + ' IN (' + params.join(', ') + ')';\n        text += ' OR ' + this.visit(binary.left) + ' IS NULL';\n        text += ')';\n      } else if (params.length) {\n        text += this.visit(binary.left) + ' NOT IN (' + params.join(', ') + ')';\n      } else { // implicitely has null\n        text += this.visit(binary.left) + ' IS NOT NULL';\n      }\n    } else {\n      text += '1=1';\n    }\n  } else {\n    text += this.visit(binary.left) + ' NOT IN ' + this.visit(binary.right);\n  }\n\n  text += ')';\n  return [text];\n};\n\nPostgres.prototype.visitCase = function(caseExp) {\n  assert(caseExp.whenList.length == caseExp.thenList.length);\n\n  var self = this;\n  var text = '(CASE';\n\n  this.visitingCase = true;\n\n  for (var i = 0; i < caseExp.whenList.length; i++) {\n    var whenExp = ' WHEN ' + this.visit(caseExp.whenList[i]);\n    var thenExp = ' THEN ' + this.visit(caseExp.thenList[i]);\n    text += whenExp + thenExp;\n  }\n\n  if (null !== caseExp.else && undefined !== caseExp.else) {\n    text += ' ELSE ' + this.visit(caseExp.else);\n  }\n\n  this.visitingCase = false;\n\n  text += ' END)';\n  return [text];\n};\n\nPostgres.prototype.visitAt = function(at) {\n  var text = '(' + this.visit(at.value) + ')[' + this.visit(at.index) + ']';\n  return [text];\n};\n\nPostgres.prototype.visitSlice = function(slice) {\n  var text = '(' + this.visit(slice.value) + ')';\n  text += '[' + this.visit(slice.start) + ':' + this.visit(slice.end) + ']';\n  return [text];\n};\n\nPostgres.prototype.visitContains = function(contains) {\n  var text = this.visit(contains.value);\n  text += ' @> ' + this.visit(contains.set);\n  return [text];\n};\n\nPostgres.prototype.visitContainedBy = function(containedBy) {\n  var text = this.visit(containedBy.value);\n  text += ' <@ ' + this.visit(containedBy.set);\n  return [text];\n};\n\nPostgres.prototype.visitOverlap = function(overlap) {\n  var text = this.visit(overlap.value);\n  text += ' && ' + this.visit(overlap.set);\n  return [text];\n};\n\nPostgres.prototype.visitQuery = function(queryNode) {\n  if (this._queryNode) return this.visitSubquery(queryNode,dontParenthesizeSubQuery(this._queryNode));\n  this._queryNode = queryNode;\n  // need to sort the top level query nodes on visitation priority\n  // so select/insert/update/delete comes before from comes before where\n  var missingFrom = true;\n  var hasFrom     = false;\n  var createView;\n  var isSelect     = false;\n  var actions = [];\n  var targets = [];\n  var filters = [];\n  for(var i = 0; i < queryNode.nodes.length; i++) {\n    var node = queryNode.nodes[i];\n    switch(node.type) {\n      case \"SELECT\":\n        isSelect = true; // jshint ignore:line\n      case \"DELETE\":\n        actions.push(node);\n        break;\n      case \"INDEXES\":\n      case \"INSERT\":\n      case \"UPDATE\":\n      case \"CREATE\":\n      case \"DROP\":\n      case \"TRUNCATE\":\n      case \"ALTER\":\n        actions.push(node);\n        missingFrom = false;\n        break;\n      case \"FROM\":\n        node.skipFromStatement = hasFrom;\n        hasFrom = true;\n        missingFrom = false;\n        targets.push(node);\n        break;\n      case \"CREATE VIEW\":\n        createView = node;\n        break;\n      default:\n        filters.push(node);\n        break;\n    }\n  }\n  if(!actions.length) {\n    // if no actions are given, guess it's a select\n    actions.push(new Select().add('*'));\n    isSelect = true;\n  }\n  if(missingFrom && queryNode.table instanceof Table) {\n\t  // the instanceof handles the situation where a sql.select(some expression) is used and there should be no FROM clause\n    targets.push(new From().add(queryNode.table));\n  }\n  if (createView) {\n    if (isSelect) {\n      actions.unshift(createView);\n    } else {\n      throw new Error('Create View requires a Select.');\n    }\n  }\n  return this.visitQueryHelper(actions,targets,filters);\n};\n\n/**\n * We separate out this part of query building so it can be overridden by other implementations.\n *\n * @param {Node[]} actions\n * @param {Node[]} targets\n * @param {Node[]} filters\n * @returns {String[]}\n */\nPostgres.prototype.visitQueryHelper=function(actions,targets,filters){\n  this.handleDistinct(actions, filters);\n  // lazy-man sorting\n  var sortedNodes = actions.concat(targets).concat(filters);\n  for(var i = 0; i < sortedNodes.length; i++) {\n    var res = this.visit(sortedNodes[i]);\n    this.output = this.output.concat(res);\n  }\n  // implicit 'from'\n  return this.output;\n};\n\nPostgres.prototype.visitSubquery = function(queryNode,dontParenthesize) {\n  // create another query builder of the current class to build the subquery\n  var subQuery = new this._myClass(this.config);\n\n  // let the subquery modify this instance's params array\n  subQuery.params = this.params;\n\n  // pass on the disable parameter placeholder flag\n  var previousFlagStatus = subQuery._disableParameterPlaceholders;\n  subQuery._disableParameterPlaceholders = this._disableParameterPlaceholders;\n  try {\n    subQuery.visitQuery(queryNode);\n  } finally {\n    // restore the flag\n    subQuery._disableParameterPlaceholders = previousFlagStatus;\n  }\n\n  var alias = queryNode.alias;\n  if (dontParenthesize) {\n  \treturn [subQuery.output.join(' ') + (alias ? ' ' + this.quote(alias) : '')];\n  }\n  return ['(' + subQuery.output.join(' ') + ')' + (alias ? ' ' + this.quote(alias) : '')];\n};\n\nPostgres.prototype.visitTable = function(tableNode) {\n  var table = tableNode.table;\n  var txt=\"\";\n  if(table.getSchema()) {\n    txt = this.quote(table.getSchema());\n    txt += '.';\n  }\n  txt += this.quote(table.getName());\n  if(typeof table.alias === 'string') {\n    txt += this._aliasText + this.quote(table.alias);\n  }\n  return [txt];\n};\n\nPostgres.prototype.visitColumn = function(columnNode) {\n  var table = columnNode.table;\n  var inInsertUpdateClause = this._visitedInsert || this._visitingUpdateTargetColumn;\n  var inDdlClause = this._visitingAddColumn || this._visitingAlter || this._visitingCreate;\n  var inSelectClause =\n    this.visitingReturning ||\n      (!this._selectOrDeleteEndIndex\n        && !this._visitingWhere   // jshint ignore:line\n        && !inInsertUpdateClause  // jshint ignore:line\n        && !inDdlClause           // jshint ignore:line\n        && !this.visitingCase     // jshint ignore:line\n        && !this._visitingJoin    // jshint ignore:line\n      );\n  var inFunctionCall = this._visitingFunctionCall;\n  var inCast = this._visitingCast;\n  var txt = [];\n  var closeParen = 0;\n  if(inSelectClause && (table && !table.alias || !!columnNode.alias)) {\n    if (columnNode.asArray) {\n      closeParen++;\n      txt.push(this._arrayAggFunctionName+'(');\n    }\n\n    if (!!columnNode.aggregator) {\n      closeParen++;\n      txt.push(columnNode.aggregator + '(');\n    }\n\n    if (columnNode.distinct === true) {\n      closeParen++;\n      txt.push('DISTINCT(');\n    }\n  }\n  if(!inInsertUpdateClause && !this.visitingReturning && !this._visitingCreate && !this._visitingAlter && !columnNode.subfieldContainer) {\n    if (table) {\n      if (typeof table.alias === 'string') {\n        txt.push(this.quote(table.alias));\n      } else {\n        if (table.getSchema()) {\n          txt.push(this.quote(table.getSchema()));\n          txt.push('.');\n        }\n        txt.push(this.quote(table.getName()));\n      }\n      txt.push('.');\n    }\n  }\n  if (columnNode.star) {\n    var allCols = [];\n    var hasAliases = false;\n    if(columnNode.aggregator !== 'COUNT') {\n      var tableName = txt.join('');\n      for (var i = 0; i < table.columns.length; ++i) {\n        var col = table.columns[i];\n        var aliased = col.name !== (col.alias || col.property);\n        hasAliases = hasAliases || aliased;\n        allCols.push(tableName + this.quote(col.name) + (aliased ? this._aliasText + this.quote(col.alias || col.property) : ''));\n      }\n    }\n    if(hasAliases) {\n      txt = [allCols.join(', ')];\n    }\n    else {\n      txt.push('*');\n    }\n  }\n  else if (columnNode.isConstant) {\n    // this injects directly into SELECT statement rather than creating a parameter\n    //   txt.push(this._getParameterValue(columnNode.literalValue))\n    // currently thinking it is better to generate a parameter\n    var value = columnNode.constantValue;\n    this.params.push(value);\n    txt.push(this._getParameterText(this.params.length, value));\n  }\n  else {\n    if (columnNode.subfieldContainer) {\n      txt.push('(' + this.visitColumn(columnNode.subfieldContainer) + ').');\n    }\n    txt.push(this.quote(columnNode.name));\n  }\n  if(closeParen) {\n    for(var j = 0; j < closeParen; j++) {\n      txt.push(')');\n    }\n  }\n  if(inSelectClause && !inFunctionCall && !inCast && (columnNode.alias || columnNode.property !== columnNode.name)) {\n    txt.push(this._aliasText + this.quote(columnNode.alias || columnNode.property));\n  }\n  if(this._visitingCreate || this._visitingAddColumn) {\n    assert(columnNode.dataType, 'dataType missing for column ' + columnNode.name +\n      ' (CREATE TABLE and ADD COLUMN statements require a dataType)');\n    txt.push(' ' + columnNode.dataType);\n\n    if (this._visitingCreate) {\n      if (columnNode.primaryKey && !this._visitCreateCompoundPrimaryKey) {\n        // creating a column as a primary key\n        txt.push(' PRIMARY KEY');\n      } else if (columnNode.notNull) {\n        txt.push(' NOT NULL');\n      }\n      if (!columnNode.primaryKey && columnNode.unique) {\n        txt.push(' UNIQUE');\n      }\n      if (columnNode.defaultValue !== undefined) {\n        txt.push(' DEFAULT ' + this._getParameterValue(columnNode.defaultValue));\n      }\n    }\n\n    if (!!columnNode.references) {\n      assert.equal(typeof (columnNode.references), 'object',\n        'references is not a object for column ' + columnNode.name +\n        ' (REFERENCES statements within CREATE TABLE and ADD COLUMN statements' +\n        ' require refrences to be expressed as an object)');\n\n      //Empty refrence objects are ok\n      if (Object.keys(columnNode.references).length > 0){\n        assert(columnNode.references.table, 'reference.table missing for column ' +\n          columnNode.name +\n          ' (REFERENCES statements within CREATE TABLE and ADD COLUMN statements' +\n          ' require a table and column)');\n        assert(columnNode.references.column, 'reference.column missing for column ' +\n          columnNode.name +\n          ' (REFERENCES statements within CREATE TABLE and ADD COLUMN statements' +\n          ' require a table and column)');\n        txt.push(' REFERENCES ');\n        if(columnNode.references.schema) {\n          txt.push(this.quote(columnNode.references.schema) + '.');\n        }\n        txt.push(this.quote(columnNode.references.table) + '(' +\n          this.quote(columnNode.references.column) + ')');\n\n        var onDelete = columnNode.references.onDelete;\n        if (onDelete) onDelete = onDelete.toUpperCase();\n        if (onDelete === 'CASCADE' || onDelete === 'RESTRICT' || onDelete === 'SET NULL' || onDelete === 'SET DEFAULT' || onDelete === 'NO ACTION') {\n          txt.push(' ON DELETE ' + onDelete);\n        }\n        var onUpdate = columnNode.references.onUpdate;\n        if (onUpdate) onUpdate = onUpdate.toUpperCase();\n        if (onUpdate === 'CASCADE' || onUpdate === 'RESTRICT' || onUpdate === 'SET NULL' || onUpdate === 'SET DEFAULT' || onUpdate === 'NO ACTION') {\n          txt.push(' ON UPDATE ' + onUpdate);\n        }\n        var constraint = columnNode.references.constraint;\n        if (constraint) {\n          constraint = ' ' + constraint.toUpperCase();\n          txt.push(constraint);\n        }\n      }\n    }\n  }\n  return [txt.join('')];\n};\n\nPostgres.prototype.visitForeignKey = function(foreignKeyNode)\n{\n  var txt = [];\n  if(this._visitingCreate) {\n    assert(foreignKeyNode.table, 'Foreign table missing for table reference');\n    assert(foreignKeyNode.columns, 'Columns missing for table reference');\n    if(foreignKeyNode.refColumns !== undefined) {\n      assert.equal(foreignKeyNode.columns.length, foreignKeyNode.refColumns.length, 'Number of local columns and foreign columns differ in table reference');\n    }\n    if(foreignKeyNode.name !== undefined) {\n      txt.push('CONSTRAINT ' + this.quote(foreignKeyNode.name) + ' ');\n    }\n    txt.push('FOREIGN KEY ( ');\n    for(var i = 0; i < foreignKeyNode.columns.length; i++) {\n      if(i>0) {\n        txt.push(', ');\n      }\n      txt.push(this.quote(foreignKeyNode.columns[i]));\n    }\n    txt.push(' ) REFERENCES ');\n    if(foreignKeyNode.schema !== undefined) {\n      txt.push(this.quote(foreignKeyNode.schema) + '.');\n    }\n    txt.push(this.quote(foreignKeyNode.table));\n    if(foreignKeyNode.refColumns !== undefined) {\n      txt.push(' ( ');\n      for(i = 0; i < foreignKeyNode.refColumns.length; i++) {\n        if(i>0) {\n          txt.push(', ');\n        }\n        txt.push(this.quote(foreignKeyNode.refColumns[i]));\n      }\n      txt.push(' )');\n    }\n    var onDelete = foreignKeyNode.onDelete;\n    if(onDelete) {\n      onDelete = onDelete.toUpperCase();\n      if(onDelete === 'CASCADE' || onDelete === 'RESTRICT' || onDelete === 'SET NULL' || onDelete === 'SET DEFAULT' || onDelete === 'NO ACTION') {\n        txt.push(' ON DELETE ' + onDelete);\n      }\n    }\n    var onUpdate = foreignKeyNode.onUpdate;\n    if(onUpdate) {\n      onUpdate = onUpdate.toUpperCase();\n      if(onUpdate === 'CASCADE' || onUpdate === 'RESTRICT' || onUpdate === 'SET NULL' || onUpdate === 'SET DEFAULT' || onUpdate === 'NO ACTION') {\n        txt.push(' ON UPDATE ' + onUpdate);\n      }\n    }\n    if(foreignKeyNode.constraint) {\n      txt.push(' ' + foreignKeyNode.constraint.toUpperCase());\n    }\n  }\n  return [txt.join('')];\n};\n\nPostgres.prototype.visitFunctionCall = function(functionCall) {\n  this._visitingFunctionCall = true;\n  var _this = this;\n\n  function _extract() {\n    var nodes = functionCall.nodes.map(_this.visit.bind(_this));\n    if (nodes.length != 1) throw new Error('Not enough parameters passed to ' + functionCall.name + ' function');\n    var txt = 'EXTRACT(' + functionCall.name + ' FROM ' + (nodes[0]+'') + ')';\n    return txt;\n  }\n\n  var txt = \"\";\n  // Override date functions since postgres (and others) uses extract\n  if (['YEAR', 'MONTH', 'DAY', 'HOUR'].indexOf(functionCall.name) >= 0) txt = _extract();\n  // Override CURRENT_TIMESTAMP function to remove parens\n  else if ('CURRENT_TIMESTAMP' == functionCall.name) txt = functionCall.name;\n  else txt = functionCall.name + '(' + functionCall.nodes.map(this.visit.bind(this)).join(', ') + ')';\n  this._visitingFunctionCall = false;\n  return [txt];\n};\n\nPostgres.prototype.visitArrayCall = function(arrayCall) {\n  var txt = 'ARRAY[' + arrayCall.nodes.map(this.visit.bind(this)).join(', ') + ']';\n  return [txt];\n};\n\nPostgres.prototype.visitParameter = function(parameter) {\n  // save the value into the parameters array\n  var value = parameter.value();\n  this.params.push(value);\n  return parameter.isExplicit ? [] : [this._getParameterText(this.params.length, value)];\n};\n\nPostgres.prototype.visitDefault = function(parameter) {\n  /* jshint unused: false */\n  return ['DEFAULT'];\n};\n\nPostgres.prototype.visitAddColumn = function(addColumn) {\n  this._visitingAddColumn = true;\n  var result = ['ADD COLUMN ' + this.visit(addColumn.nodes[0])];\n  this._visitingAddColumn = false;\n  return result;\n};\n\nPostgres.prototype.visitDropColumn = function(dropColumn) {\n  return ['DROP COLUMN ' + this.visit(dropColumn.nodes[0])];\n};\n\nPostgres.prototype.visitRenameColumn = function(renameColumn) {\n  return ['RENAME COLUMN ' + this.visit(renameColumn.nodes[0]) + ' TO ' + this.visit(renameColumn.nodes[1])];\n};\n\nPostgres.prototype.visitRename = function(rename) {\n  return ['RENAME TO ' + this.visit(rename.nodes[0])];\n};\n\nPostgres.prototype.visitIfExists = function() {\n  return ['IF EXISTS'];\n};\n\nPostgres.prototype.visitIfNotExists = function() {\n  return ['IF NOT EXISTS'];\n};\n\nPostgres.prototype.visitOrIgnore = function() {\n  throw new Error('PostgreSQL does not allow orIgnore clause.');\n};\n\nPostgres.prototype.visitCascade = function() {\n  return ['CASCADE'];\n};\n\nPostgres.prototype.visitRestrict = function() {\n  return ['RESTRICT'];\n};\n\nPostgres.prototype.visitForUpdate = function() {\n  return ['FOR UPDATE'];\n};\n\nPostgres.prototype.visitForShare = function() {\n  return ['FOR SHARE'];\n};\n\nPostgres.prototype.visitJoin = function(join) {\n  var result = [];\n  this._visitingJoin = true;\n  result = result.concat(this.visit(join.from));\n  result = result.concat(join.subType + ' JOIN');\n  result = result.concat(this.visit(join.to));\n  result = result.concat('ON');\n  result = result.concat(this.visit(join.on));\n  return result;\n};\n\nPostgres.prototype.visitLiteral = function(node) {\n  var txt = [node.literal];\n  if(node.alias) {\n    txt.push(this._aliasText + this.quote(node.alias));\n  }\n  return [txt.join('')];\n};\n\nPostgres.prototype.visitReturning = function(returning) {\n  this.visitingReturning = true;\n  var r = ['RETURNING', returning.nodes.map(this.visit.bind(this)).join(', ')];\n  this.visitingReturning = false;\n\n  return r;\n};\n\nPostgres.prototype.visitOnDuplicate = function(onDuplicate) {\n  throw new Error('PostgreSQL does not allow onDuplicate clause.');\n};\n\nPostgres.prototype.visitOnConflict = function(onConflict) {\n  var result = ['ON CONFLICT'];\n  var columns = [];\n  var updateClause = [], i, col;\n  var table = this._queryNode.table;\n  if(onConflict.constraint)\n    result.push(['ON CONSTRAINT', this.quote(onConflict.constraint)].join(' '));\n  else if(onConflict.columns) {\n    for(i=0; i < onConflict.columns.length; i++) {\n      columns.push(this.quote(table.getColumn(onConflict.columns[i]).name));\n    }\n    result.push( '(' + columns.join(', ') + ')' );\n  }\n    \n  if(onConflict.update){\n    updateClause.push(\"DO UPDATE SET\");\n    var update = onConflict.update;\n    var setClause = [];\n    for(i=0; i<update.length; i++) {\n      col = this.quote(table.getColumn(update[i]).name);\n      setClause.push(col + ' = EXCLUDED.' + col);\n    }\n    updateClause.push(setClause.join(', '));\n  }\n  else \n    updateClause.push('DO NOTHING');\n\n  result.push(updateClause.join(' '));\n  return result; \n};\n\nPostgres.prototype.visitModifier = function(node) {\n  return [node.type, node.count.type ? this.visit(node.count) : node.count];\n};\n\nPostgres.prototype.visitIndexes = function(node) {\n  /* jshint unused: false */\n  var tableName = this._queryNode.table.getName();\n  var schemaName = this._queryNode.table.getSchema() || \"public\";\n\n  return [\n    \"SELECT relname\",\n    \"FROM pg_class\",\n    \"WHERE oid IN (\",\n    \"SELECT indexrelid\",\n    \"FROM pg_index, pg_class WHERE pg_class.relname='\" + tableName + \"'\",\n    \"AND pg_class.relnamespace IN (SELECT pg_namespace.oid FROM pg_namespace WHERE nspname = '\" + schemaName + \"')\",\n    \"AND pg_class.oid=pg_index.indrelid)\"\n  ].join(' ');\n};\n\nPostgres.prototype.visitCreateIndex = function(node) {\n  if (!node.options.columns || (node.options.columns.length === 0)) {\n    throw new Error('No columns defined!');\n  }\n\n  var tableName = this.visit(node.table.toNode());\n  var result    = [ 'CREATE' ];\n\n  if (node.options.type) {\n    result.push(node.options.type.toUpperCase());\n  }\n\n  result = result.concat([ 'INDEX', this.quote(node.indexName()) ]);\n\n  if (node.options.algorithm) {\n    result.push(\"USING \" + node.options.algorithm.toUpperCase());\n  }\n\n  result = result.concat([\n    \"ON\",\n    tableName,\n    \"(\" + node.options.columns.reduce(function(result, col) {\n      var column = col.name ? col.name : col.value.name;\n      var direction = col.direction ? ' ' + col.direction.text : '';\n      var res = result.concat(this.quote(column) + direction);\n      return res;\n    }.bind(this), []) + \")\"\n  ]);\n\n  if (node.options.parser) {\n    result.push(\"WITH PARSER\");\n    result.push(node.options.parser);\n  }\n\n  return result;\n};\n\nPostgres.prototype.visitDropIndex = function(node) {\n  var result = [ 'DROP INDEX' ];\n\n  result.push(this.quote(node.table.getSchema() || \"public\") + \".\" + this.quote(node.options.indexName));\n\n  return result;\n};\n\nPostgres.prototype.visitCreateView = function(createView) {\n  var result = ['CREATE VIEW', this.quote(createView.options.viewName), 'AS'];\n  return result;\n};\n\nPostgres.prototype.visitInterval = function(interval) {\n  var parameter = '';\n  function _add(n, unit) {\n    if(!_.isNumber(n)) return;\n    if(parameter !== '') {\n      parameter += ' ';\n    }\n    parameter += n + ' ' + unit;\n  }\n  _add(interval.years, 'YEAR');\n  _add(interval.months, 'MONTH');\n  _add(interval.days, 'DAY');\n  _add(interval.hours, 'HOUR');\n  _add(interval.minutes, 'MINUTE');\n  _add(interval.seconds, 'SECOND');\n  if(parameter === '') parameter = '0 SECOND';\n  var result = \"INTERVAL '\" + parameter + \"'\";\n  return result;\n};\n\n/**\n * Broken out as a separate function so that dialects that derive from this class can still use this functionality.\n *\n * @param {Node[]} list\n * @param {String} type\n * @returns {Object|undefined} {index:number, node:Node}\n */\nPostgres.prototype.findNode=function(list,type) {\n  for (var i= 0, len=list.length; i<len; i++) {\n    var n=list[i];\n    if (n.type==type) return {index:i,node:n};\n  }\n  return undefined;\n};\n\n/**\n * pulls the DISTINCT node out of the filters and flags the SELECT node that it should be distinct.\n * Broken out as a separate function so that dialects that derive from this class can still use this functionality.\n */\nPostgres.prototype.handleDistinct = function(actions,filters) {\n  var distinctNode = this.findNode(filters,\"DISTINCT\");\n  //if (!distinctNode) distinctNode = _findNode(targets,\"DISTINCT\");\n  //if (!distinctNode) distinctNode = _findNode(actions,\"DISTINCT\");\n  if (!distinctNode) return;\n  var selectInfo = this.findNode(actions,\"SELECT\");\n  if (!selectInfo) return; // there should be one by now, I think\n  // mark the SELECT node that it's distinct\n  selectInfo.node.isDistinct = true;\n};\n\n/**\n * If the parent of the subquery is an INSERT we don't want to parenthesize.\n * This happens when you create the query like so:\n *\n * var query=post.insert(post.id)\n * var select=user.select(user.id)\n * query.add(select)\n *\n * @param parentQuery\n * @returns {boolean}\n */\nfunction dontParenthesizeSubQuery(parentQuery){\n\tif (!parentQuery) return false;\n\tif (parentQuery.nodes.length === 0) return false;\n\tif (parentQuery.nodes[0].type != 'INSERT') return false;\n\treturn true;\n}\n\nmodule.exports = Postgres;\n","/home/travis/build/npmtest/node-npmtest-sql/node_modules/sql/runtests.js":"var childProcess = require(\"child_process\");\nvar path = require(\"path\");\n\nvar env = process.env;\nenv.NODE_ENV = \"test\";\n\nvar options = {\n  env: env\n};\n\nvar command = path.join(\".\", \"node_modules\", \".bin\", \"mocha\");\nif (process.platform == \"win32\") command += \".cmd\";\nvar run = childProcess.spawn(command, [], options);\nrun.stdout.pipe(process.stdout);\nrun.stderr.pipe(process.stderr);\nrun.on('close', function(code) {\n  process.exit(code);\n});\n"}